#set text(size: 2em)
- 垃圾回收算法
  - 标记清除算法
  对垃圾标记，记录地址
  #image("Screenshot_20250722_211852.png")
  优点：速度快
  缺点：容易产生内存碎片（空间不连续）
  - 标记整理算法
  对垃圾标记，记录地址
  #image("Screenshot_20250722_212211.png")
  整理，会移动对象

  缺点：移动对象，内存空间地址变，拷贝移动，速度慢
  - 复制算法
  #image("Screenshot_20250722_212338.png")
  两片区域

  标记垃圾，将有用对象移动到新的区域

  缺点：占用双倍内存空间
- 分代回收
  #image("Screenshot_20250722_212739.png")
  新生代的内存经常清除，老年代对象价值高，不经常清除

  产生对象分配到伊甸园，伊甸园满了产生minor GC

  minor GC会触发stop the world 暂停其他用户的线程运行，等垃圾回收结束，用户线程才会恢复

  利用复制算法复制到幸存区TO，让对象幸存寿命+1

  minor GC完成后交换幸存区FORM和TO位置
  #image("Screenshot_20250722_213014.png")

  第二次满了之后，伊甸园的继续分配到幸存区TO，看幸存区FROM是否有继续保存的，若有保存的分配到幸存区TO并且寿命+1，不用保存的就清除，再交换FROM和TO位置
  #image("Screenshot_20250722_213225.png")
  若一个对象寿命超过阈值，最大寿命为15（4bit），分配到老年代（阈值不一定是15）
  #image("Screenshot_20250722_213346.png")
  新生代老年代都满了，先尝试触发minor GC，如果还是空间不足，触发FULLGC，stop the world 时间更长

  新生代老年代都清理

  如果老年代空间足够，新生代空间不足，会直接晋升，不触发GC

  若minor GC和FULLGC执行完还是内存不足，就会导致OOM

  当一个线程OOM,不会导致进程结束

- 相关VM参数
  #image("Screenshot_20250722_214059.png")
- 垃圾回收器
  - 串行
    - 单线程  
    - 堆内存较小，适合个人电脑

    #image("Screenshot_20250723_205429.png")
    分为新生代和老年代，新生代用复制，老年代用标记整理

    在垃圾回收前，所有线程都要运行到安全点

    因为serial是单线程运行，所以除了垃圾回收线程，其他线程都要阻塞
  - 吞吐量优先
    - 多线程 
    - 堆内存较大，适合多核CPU
    - 让单位时间内STW时间最短  在总时间上可能优于响应时间优先 0.2+ 0.2 = 0.4 
  

    垃圾时间占比越低，吞吐量越高

    #image("Screenshot_20250723_210441.png")
    垃圾回收算法一致，可以设置线程数，运行到安全点同时垃圾回收

    可以动态调整新生代内存分布

    可以设置垃圾回收时间与总时间的占比  如果无法达到，会调整堆的大小

    可以设置最大暂停毫秒数 和堆的大小相关

    但是这两者对立，垃圾回收时间和暂停时间需要折中选择

  - 响应时间优先
    - 多线程 
    - 堆内存较大，适合多核CPU
    - 尽可能让单次STW的时间最短  0.1+0.1+0.1+0.1+0.1=0.5

    #image("Screenshot_20250723_211022.png")
    - 标记清除算法

    初始标记很快 并发标记和用户线程并行 重新标记要stw 最后并发清理

    可设置垃圾回收线程数和并行线程数

    要将并行线程中的某些线程分给垃圾回收，会影响运行速度

    因为是并行清理，不能回收新垃圾（浮动垃圾），需要预留空间保存浮动垃圾

    所以可以设置何时进行垃圾回收，如当内存占满百分之60就回收，那就达到了预留空间的效果

    可以设置重新标记前是否对新生代垃圾进行回收

    内存碎片过多导致并发失败，导致垃圾回收时间长
- G1
  - 同时注重吞吐量和低延迟，默认暂停目标是200ms
  - 超大堆内存，会将堆划分为多个大小相等的region
  - 整体上是标记+整理算法，两个区域之间是复制算法
  - 垃圾回收过程
    - 新生代垃圾回收
      - 新加载对象分配到伊甸园
      - 伊甸园占满触发新生代垃圾回收
      - 幸存对象用拷贝算法复制到幸存区
      - 幸存区对象较多，年龄长的到老年代
      - 不够年龄复制的到另一个幸存区
    - 新生代回收+并发标记 
      - young GC会进行GC root的初始标记
      - 老年代占用堆空间比例达到阈值时，会并发标记（不会stw）
    - 混合回收
      - 会对E，S,O全面垃圾回收
      - 选择回收价值高的回收
      - 最终标记和拷贝存活都stw

    #image("Screenshot_20250723_214507.png")
    g1回收速度跟不上垃圾回收速度才会fullgc

    cms垃圾回收失败会fullgc
    - 新生代的跨代引用
    老年代 引用新生代对象 是脏卡

    搜索老年代就只用搜索脏卡

    - remark 重新标记算法
    
    当对象引用发生改变，要写屏障

    在对象引用改变前将对象加入队列，表示未被处理

    就可以防止对象在被标记为垃圾时对象引用改变导致出错
    - 字符串去重
    #image("Screenshot_20250723_220456.png")
    - 并发标记类卸载
    #image("Screenshot_20250723_220717.png")
    类的实例也会卸载
    - 回收巨型对象
    #image("Screenshot_20250723_221004.png")
    - 动态调整阈值
    #image("Screenshot_20250723_221157.png")
- GC调优
  - 查看fullGC前后
    - 数据是否太多
    - 数据表示是否太臃肿
    - 是否存在内存泄漏
      最好使用第三方缓存
  - 新生代调优 
    - 新生代特点
        - TLAB线程局部私有内存
        - 死亡对象回收代价为0
        - 大部分对象用过即死
        - minor GC时间远低于FullGC

    - 新生代内存不能太大，老年代内存小，可能只会触发fullgc 最好大于百分之25小于百分之50
    - 最好划分新生代为能容纳 并发量\*（请求-响应）
    - 幸存区大到能保留（当前活跃对象+需要晋升对象）
    - 晋升阈值让长时间存活对象尽快晋升
  - 老年代调优 
    - CMS老年代内存越大越好
    - 先尝试不调优，如果没有fullgc说明老年代正常运行，就算有fullgc也先尝试调优新生代
    - 观察fullgc时老年代内存占用，将老年代内存预设调大四分之一或三分之一
    - 案例
    - minorGC和FullGC频繁
      - 内存少，晋升周期短，fullgc发生经常
      - 增大新生代空间和新生代内存和晋升阈值
    - 请求高峰期发生fullgc，单次暂停时间长（CMS）
      - 判断哪个阶段时间长
      - 重新标记时间长
      - 重新标记前先对新生代垃圾回收
    - 老年代充裕，fullgc
      - jdk1.7 永久代也会fullgc
      - 1.8之后元空间，用操作系统的，一般不会满
- 类加载
  - 魔数
    
    表示它是否是class类型的文件

  - 版本
    
    00 34（52） 表示java8

  - 常量池

    - 常量池长度 0023（35）表示1-34项 0项不计入也没有值
    - 对于每一项
      - Method信息
        - 有所属类和方法名
      - 引用常量池
      - 表示utf8串
      - 表示class信息
  （太抽象没听跳到下一章）
- javap 
  
  反编译class文件
-  字节码指令没看，直到多态原理
- HSDB

  禁用指针压缩
- 异常处理
  
  - exception table
  - 多try catch 复用槽位
  - multi-catch 
  - finally对try和catch再次匹配

    也就是说 finally中的代码被复制了三份，分别放入try，catch以及catch剩余的异常类型流程
- 语法糖
  - 默认构造
  - 自动拆装箱
  - 泛型集合取值（举integer为例子）
    - 在调用时用object
    - 最后将object转integer
    #image("Screenshot_20250728_204143.png")
    - 泛型反射
  - 可变参数
      - String... args 其实就是 String[] args
      #image("Screenshot_20250728_204547.png")
      如果调用了foo,创建空数组而不是传null
  - foreach
    #image("Screenshot_20250728_204646.png")
    #image("Screenshot_20250728_204838.png")
    集合循环转换为迭代器

    能够配合数组和实现了迭代器接口的集合类使用
  - switch
      - 可以作用于字符串和枚举类
        - 字符串
          - hashcode增加效率
          - equals避免哈希碰撞
        - 枚举
  - 枚举类
    - 等价于class,final修饰，属性就是静态成员常量，还会创建枚举实例对象以及value
    #image("Screenshot_20250728_205807.png")
  - try-with-resources
    
    - 释放资源
    - 压制异常

  - 方法重写时的桥接方法
    #image("Screenshot_20250728_210350.png")
    #image("Screenshot_20250728_210501.png")
    桥接方法仅对java虚拟机可见
  - 匿名内部类
    #image("Screenshot_20250728_210652.png")
    #image("Screenshot_20250728_210806.png")
- 类加载
   #image("Screenshot_20250729_211625.png")

   #image("Screenshot_20250729_211733.png")
   - 链接
     - 验证： 验证类是否符合jvm规范
     - 准备：  为static分配空间，设置默认值
        - 分配空间和赋值分两个阶段，分配空间在准备阶段，赋值在初始化阶段
        - 如果是final类型，在准备阶段赋值
        - 如果是final,但是是引用类型（如引用新new的一个对象），也在初始化阶段赋值
    - 解析： 
      - 将常量池中的符号引用解析为直接引用
      #image("Screenshot_20250729_212956.png")
      JVM 在类加载过程中（尤其是“链接”阶段的“解析”子阶段）会将这些符号引用转换成“直接引用”，也就是实际在内存中的地址或偏移量，用于快速访问。
    - 初始化
      - 调用cinit
      - #image("Screenshot_20250729_213057.png")
      #image("Screenshot_20250729_215332.png")
      这是懒汉式，调用外部类时静态内部类不会被加载和初始化，只有显示调用静态内部类才会初始化singleton,而且这是线程安全的，可以从static全局共享或者从jvm类加载机制说
- 类加载器
  #image("Screenshot_20250730_151342.png")
  - 启动类加载器
  - 双亲委派
    - 调用类加载器的loadclass方法会先从父类查找
  - 线程上下文类加载器（应用程序类加载器）
  - 自定义类加载器
    #image("Screenshot_20250730_153410.png")
    类加载器不同，classloader的loadclass也不同
- 运行期优化
  - 逃逸分析
  #image("Screenshot_20250731_152607.png")
  - 方法内联
  #image("Screenshot_20250731_153026.png")
  - 字段优化
  #image("Screenshot_20250731_153909.png")
- 反射优化
  - 前十五次的字节码文件反射执行，后面不是，效率提高
- JMM
  - 定义在多线程读写共享数据时，对数据可见性，有序性和原子性的规则和保障
  - 原子性
    - synchronized
      - monitor
        - owner
        - entrylist
      - 原子性和可见性
      - 重量级操作，性能相对低
  - 可见性
    #image("Screenshot_20250801_163846.png")
    #image("Screenshot_20250801_163824.png")
    #image("Screenshot_20250801_163834.png")
  - volatile
    - #image("Screenshot_20250801_163957.png")
    - 保证在多线程之间，一个线程对volatile变量的修改对另一个线程可见，不保证原子性，只适用于一写多读
  - print也有synchronized修饰，强制线程从主存中读取
  - 有序性
    - 指令重排
      - volatile禁止指令重排
      - 双重加锁有问题
      #image("Screenshot_20250801_165533.png")
      - 原因是先分配地址，后初始化，在没初始化时有线程进来判断到对象不为空，但还没初始化就返回了
    - happens-before
  - CAS
    - 乐观锁
    - 竞争不激烈，多核CPU
      #image("Screenshot_20250801_171134.png")
    - UNSAFE类实现
    - unsafe对象不能直接调用，只能反射获得
    - 乐观锁与悲观锁的不同
    - 原子操作类
  - synchronized优化
    - java HotSpot虚拟机中，每个对象都有对象头，包括class指针和markword。markword平时存储这个对象的哈希码，分代年龄，当加锁时，这些信息就根据情况被替换为标记位，线程锁记录指针，重量级锁指针，线程ID等内容
    - 轻量级锁
      - 多线程访问的时间是错开的
    - 锁膨胀
      - 有竞争
    - 重量锁优化 
      - 自旋重试
      - 超过自旋次数阻塞
      - 自选次数自适应
      - 自旋会占用cpu时间，多核cpu才能发挥优势
    - 偏向锁 
     #image("Screenshot_20250804_102243.png")
    - 减少上锁时间（synchronized代码块尽量短）
    - 减少锁的粒度
    - 锁粗化（如stringbuffer多次append的加锁操作粗化为一次）
    - 锁消除
      - jvm会进行代码的逃逸分析，例如某个加锁对象是方法内局部变量，不会被其他线程所访问到，这时候就会被即时编译器忽略掉所有同步操作
    - 读写分离