- 分布式架构
  - 根据业务功能对系统进行拆分
    - 优点
      - 降低服务耦合
      - 有利于服务升级拓展
- 微服务是一种分布式架构方案
  - 单一职责，避免业务重复开发
  - 面向服务，微服务对外暴露业务接口
  - 团队独立，技术独立，数据独立，部署独立
  - 隔离性强，服务调用做好隔离，容错，降级，避免出现级联问题
- 微服务技术对比
  #image("Screenshot_20250805_104238.png")
- 企业需求
  #image("Screenshot_20250805_104434.png")
- 服务拆分注意事项
  - 不同微服务不要重复开发相同业务
  - 微服务数据独立，不要访问其他微服务的数据库
  - 微服务可以将自己的业务接口暴露
- 服务远程调用
  - 注册resttemplate对象
  #image("Screenshot_20250805_110413.png")
  - resttemplate的getforobject发送http请求
  #image("Screenshot_20250805_110350.png")
  - 提供者与消费者
    - 服务提供者是被其他微服务调用的服务，提供接口
    - 消费者是调用其他微服务的服务，调用接口
    - 服务A调用B，B调用C，服务B既可以是提供者也可以是消费者，主要看相对于哪个业务来说
- Eureka注册中心
  #image("Screenshot_20250806_100952.png")
  - 消费者如何获取服务提供者的具体信息
    - 服务提供者启动时向Eureka注册自己的信息
    - eureka保存这些信息
    - 消费者根据服务名称向eureka拉取提供者信息
  - 如果有多个服务提供者，消费者该如何选择
    - 服务消费者利用负载均衡算法，从服务列表挑选一个
  - 消费者如何感知服务提供者健康状态
    - 服务提供者会每隔30秒向EurekaServer发送心跳请求，报告健康状态
    - eureka会更新记录服务列表信息，心跳不正常会被剔除
    - 消费者就可以拉到最新的消息
    #image("Screenshot_20250806_101418.png")
  - 使用eureka
    - 搭建eurekaservice
      + 引入依赖
      + 添加enableeurekaserver注解
      + 创建配置类注册信息（需要注册eureka的地址，若后面有多个eureka集群可以相互传递信息）
    - 服务注册
      + 引入依赖
      + 配置地址和name
      - 如果多实例部署，可以多次启动user-service，注意要修改端口设置避免冲突
    - 在order-service完成服务拉取（服务发现）
      - 修改url为服务名称
      - 负载均衡加loadbalence注解
- Ribbon负载均衡
  #image("Screenshot_20250806_103311.png")
  - 负载均衡流程
  #image("Screenshot_20250806_103806.png")
  - 负载均衡策略
  #image("Screenshot_20250806_111021.png")
  默认实现是zoneavoidancerule，根据zone选择服务列表然后轮询
  - 自定义策略
    - 新定义新bean然后用Irule接口new一个规则（全局）（修改时需要打包）
    - 配置文件（针对某个微服务）（无需重新打包）
  - Ribbon默认是懒加载，第一次访问才会创建loadbalanceclient，请求时间长，后续访问时间短
  - 可以修改为饥饿加载，在项目启动时就创建loadbalanceclient，降低第一次访问的耗时
- Nacos注册中心
  - 启动
    - 在bin目录下运行指令单机启动
    - 导入依赖
    - 修改地址
    - 其实跟eureka差不多
  - Nacos服务分级存储模型
    - 一级是服务，如userservice
    - 二级是集群，如杭州集群
    - 三级是实例，如杭州机房某台部署了userservice的服务器
  - 服务跨集群调用
    - 最好本地调用
  - 服务集群属性
    - 配置文件修改cluster-name修改集群位置
  - 实现优先选择本地集群
    - 给orderservice也修改集群位置
    - 修改rule为nacosrule
    - 在本地集群内采用随机选择实例
    - 若本地没有会跨集群访问，会警告
  - 根据权重负载均衡
    - 可以在nacos控制台修改权重，权重为0不会访问
    - 可以实现版本平滑升级
  - 环境隔离
    - 在nacos可以创建namespace用来隔离不同环境
    - 然后填写一个新的命名空间信息
    - 保存会会生成id
    - 在配置文件添加id
    - 不同namespace下的服务不可见
  - 服务消费者向注册中心拉取信息会保存一个缓存，不用一直向注册中心拉取，大概每隔30秒重新拉取一次
  - 健康检测
    - 临时实例，采用心跳检测，不跳就剔除
    - 非临时实例，nacos主动询问，不会主动剔除
    - 在配置文件配置ephemeral
  - 主动推送变更信息push
  - 和eureka区别
  #image("Screenshot_20250806_165729.png")
  - CAP原则
    - CAP原则又称CAP定理，指的是在一个分布式系统中，一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）。

    - CAP原则的精髓就是要么AP，要么CP，要么AC，但是不存在CAP。
    - CA without P：如果不要求P（不允许分区），则C（强一致性）和A（可用性）是可以保证的。但放弃P的同时也就意味着放弃了系统的扩展性，也就是分布式节点受限，没办法部署子节点，这是违背分布式系统设计的初衷的。传统的关系型数据库RDBMS：Oracle、MySQL就是CA。
    - CP without A：如果不要求A（可用），相当于每个请求都需要在服务器之间保持强一致，而P（分区）会导致同步时间无限延长(也就是等待数据同步完才能正常访问服务)，一旦发生网络故障或者消息丢失等情况，就要牺牲用户的体验，等待所有数据全部一致了之后再让用户访问系统。设计成CP的系统其实不少，最典型的就是分布式数据库，如Redis、HBase等。对于这些分布式数据库来说，数据的一致性是最基本的要求，因为如果连这个标准都达不到，那么直接采用关系型数据库就好，没必要再浪费资源来部署分布式数据库。
    -  AP wihtout C：要高可用并允许分区，则需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。典型的应用就如某米的抢购手机场景，可能前几秒你浏览商品的时候页面提示是有库存的，当你选择完商品准备下单的时候，系统提示你下单失败，商品已售完。这其实就是先在 A（可用性）方面保证系统可以正常的服务，然后在数据的一致性方面做了些牺牲，虽然多少会影响一些用户体验，但也不至于造成用户购物流程的严重阻塞。
    - 解决方案：BASE。即使无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。
  - 统一配置管理
    - 配置更改热更新
    - 配置管理服务
      - 在配置内容中放经常变更的有热更新需求的
      - 配置文件id要加上微服务名称前缀防止冲突
    - 新建bootstrap.yml,导入依赖，在yml文件中配置nacos地址，环境，服务名称，文件后缀名
    - 配置热更新
      - 在value注解所在的类加refreshscope注解
      - 或者通过configurationproperties注入，自动刷新
    - 多环境配置共享
      - 配置文件优先级
        - 服务名称-profile.yaml>服务名称.yaml>本地配置
    - Nacos集群搭建
      - 搭建mysql集群并初始化表
      - 下载解压nacos
      - 修改集群配置，数据库配置
      - 分别启动多个nacos节点
      - nginx反向代理
- Dockers
  - docker在运行环境时创建一个隔离环境
  - 当我们利用docker安装应用时，docker会自动搜索并下载应用镜像
  - 镜像仓库：存储和管理镜像的平台
  #image("Screenshot_20250807_214730.png")
  - 常用命令
  #image("Screenshot_20250807_215135.png")
  - 如果宿主机端口已被占用则无法正常run,所以需要找未被占用的宿主机端口
  - nano ~/.bashrc自定义快捷命令别名
  - 数据卷
     - 容器内目录与宿主机目录之间的桥梁
     - 对宿主机目录操作和容器同步
     - 数据卷挂载会生成匿名卷，而mysql每次run就会新产生匿名卷，每次都需要拷贝数据
     - 因此可以本地挂载
     #image("Screenshot_20250808_102809.png")
     #image("Screenshot_20250808_102945.png")
  - 自定义镜像
    - 层
    - 基础镜像
    - 入口
    - dockerfile
      #image("Screenshot_20250808_105027.png")
    - 阿里云容器镜像服务acr
  - 网络
    - 加入自定义网络的容器才可以通过容器名互相访问（默认网络不可以）
    - 如果在创建容器时指定了网桥，就不会再进入默认的
- Feign
  - resttemplate难以维护
  - Feign是一个声明式的http客户端
  - 负载均衡集成ribbon
  - 配置
    + 日志级别
    + 响应结果的解析器
    + 请求参数编码
    + 支持的注解格式
    + 失败重试机制
  - 性能优化
    - 底层的客户端实现
      - URLConnection：默认实现，不支持连接池
      - Apache httpclient：支持连接池
      - OKhttp
    - 优化Feign的性能
      + 使用连接池代替默认的URLConnection
      + 日志级别最好用basic或none
  - 最佳实践
    - #image("Screenshot_20250815_223907.png")
    - #image("Screenshot_20250815_224119.png")
    - springboot扫描包范围只在启动类所在目录，而feign提出后不在这里，所以需要配置
    
