= 场景题
- 设计一个广告计费系统，用户曝光点击会产生计费，有每日限额，如何设计，可能遇到什么问题及如何解决？最后一块钱问题怎么解决？
  - 系统要求
    - 曝光和点击触发扣费事件
    - 限额规则
      - 每个广告主每日预算
      - 系统必须保证不超支
    - 高并发要求
      - 每天可能亿级曝光和百万级点击
      - 计费需要实时或者准实时
    - 精度要求
      - 每一笔计费必须精确，最后一块钱不能丢
    - 每日重置
  - 系统设计 
    - 收集曝光/点击事件 → 发送到 消息队列
    - 消费消息队列 → 更新广告消耗
    - 支持每日限额检查
    - 实时计费层（Redis/内存缓存计数）保证快速读取和更新
    - 落地计费层（MySQL / ClickHouse / HBase）存储最终计费记录和统计
    - Redis和MYSQL的同步可以异步
    - Redis counter 每日 0 点重置
  - 问题和解决方案
    - 高并发计数导致超支
      - 使用 Redis 原子操作（HINCRBYFLOAT / Lua 脚本）保证限额不被超越
    - 分布式并发导致超支
      - 全局计数使用 Redis 分布式锁 / 原子脚本
    - 数据落地延迟
      - 批量写数据库，并异步补偿，保证账目最终一致
    - 精度问题（浮点误差）
      - 使用 整数计费（分为最小货币单位，如分） 避免浮点精度问题
    - 宕机导致丢数据
      - 消息队列保证 事件至少一次投递，落地时支持 幂等
  - 最后一块钱问题
    - 当广告剩余预算不足以覆盖一次曝光或点击时，如何处理？
      - 不投放策略
      - 按比例扣费
  

- ConcurrentHashMap底层
  - 在 JDK 1.7 中它使用的是数组加链表的形式实现的，而数组又分为：大数组 Segment 和小数组 HashEntry。 Segment 是一种可重入锁（ReentrantLock），在 ConcurrentHashMap 里扮演锁的角色；HashEntry 则用于存储键值对数据。一个 ConcurrentHashMap 里包含一个 Segment 数组，一个 Segment 里包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素。
  - 在 JDK 1.7 中，ConcurrentHashMap 虽然是线程安全的，但因为它的底层实现是数组 + 链表的形式，所以在数据比较多的情况下访问是很慢的，因为要遍历整个链表，而 JDK 1.8 则使用了数组 + 链表/红黑树的方式优化了 ConcurrentHashMap 的实现
  - JDK 1.8 ConcurrentHashMap JDK 1.8 ConcurrentHashMap 主要通过 volatile + CAS 或者 synchronized 来实现的线程安全的。添加元素时首先会判断容器是否为空：
    - 如果为空则使用 volatile 加 CAS 来初始化
    - 如果容器不为空，则根据存储的元素计算该位置是否为空。 
      - 如果根据存储的元素计算结果为空，则利用 CAS 设置该节点；
      - 如果根据存储的元素计算结果不为空，则使用 synchronized ，然后，遍历桶中的数据，并替换或新增节点到桶中，最后再判断是否需要转为红黑树，这样就能保证并发访问时的线程安全了。
  - 如果把上面的执行用一句话归纳的话，就相当于是ConcurrentHashMap通过对头结点加锁来保证线程安全的，锁的粒度相比 Segment 来说更小了，发生冲突和加锁的频率降低了，并发操作的性能就提高了。
  - 而且 JDK 1.8 使用的是红黑树优化了之前的固定链表，那么当数据量比较大的时候，查询性能也得到了很大的提升，从之前的 O(n) 优化到了 O(logn) 的时间复杂度。
  - 分段锁怎么加锁的？
    - 在 ConcurrentHashMap 中，对于插入、更新、删除等操作，需要先定位到具体的 Segment，然后再在该 Segment 上加锁，而不是像传统的 HashMap 一样对整个数据结构加锁。这样可以使得不同 Segment 之间的操作并行进行，提高了并发性能。
    
  - 分段锁是可重入的吗？
    - JDK 1.7 ConcurrentHashMap中的分段锁是用了 ReentrantLock，是一个可重入的锁。
  
  - 已经用了synchronized，为什么还要用CAS呢
    - ConcurrentHashMap使用这两种手段来保证线程安全主要是一种权衡的考虑，在某些操作中使用synchronized，还是使用CAS，主要是根据锁竞争程度来判断的。
    - 比如：在putVal中，如果计算出来的hash槽没有存放元素，那么就可以直接使用CAS来进行设置值，这是因为在设置元素的时候，因为hash值经过了各种扰动后，造成hash碰撞的几率较低，那么我们可以预测使用较少的自旋来完成具体的hash落槽操作。
    - 当发生了hash碰撞的时候说明容量不够用了或者已经有大量线程访问了，因此这时候使用synchronized来处理hash碰撞比CAS效率要高，因为发生了hash碰撞大概率来说是线程竞争比较强烈。
