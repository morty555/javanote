= 场景题
- 设计一个广告计费系统，用户曝光点击会产生计费，有每日限额，如何设计，可能遇到什么问题及如何解决？最后一块钱问题怎么解决？
  - 系统要求
    - 曝光和点击触发扣费事件
    - 限额规则
      - 每个广告主每日预算
      - 系统必须保证不超支
    - 高并发要求
      - 每天可能亿级曝光和百万级点击
      - 计费需要实时或者准实时
    - 精度要求
      - 每一笔计费必须精确，最后一块钱不能丢
    - 每日重置
  - 系统设计 
    - 收集曝光/点击事件 → 发送到 消息队列
    - 消费消息队列 → 更新广告消耗
    - 支持每日限额检查
    - 实时计费层（Redis/内存缓存计数）保证快速读取和更新
    - 落地计费层（MySQL / ClickHouse / HBase）存储最终计费记录和统计
    - Redis和MYSQL的同步可以异步
    - Redis counter 每日 0 点重置
  - 问题和解决方案
    - 高并发计数导致超支
      - 使用 Redis 原子操作（HINCRBYFLOAT / Lua 脚本）保证限额不被超越
    - 分布式并发导致超支
      - 全局计数使用 Redis 分布式锁 / 原子脚本
    - 数据落地延迟
      - 批量写数据库，并异步补偿，保证账目最终一致
    - 精度问题（浮点误差）
      - 使用 整数计费（分为最小货币单位，如分） 避免浮点精度问题
    - 宕机导致丢数据
      - 消息队列保证 事件至少一次投递，落地时支持 幂等
  - 最后一块钱问题
    - 当广告剩余预算不足以覆盖一次曝光或点击时，如何处理？
      - 不投放策略
      - 按比例扣费
  

- 秒杀优惠券的核心需求
  - 高并发发放：短时间内可能有成千上万用户请求。
  - 库存控制：优惠券数量有限，不能超发。
  - 防刷机制：防止刷单、恶意抢券。
  - 实时性：用户要尽快知道抢到还是抢不到。
  - 可扩展性：在用户量大时系统仍能稳定。
  - 秒杀抢券的常见策略
    - 方案 A：数据库行锁 (悲观锁)
      - 优点：简单，保证不超发。
      - 缺点：高并发下会成为数据库瓶颈，容易锁表或锁行。
    - 方案 B：乐观锁 + 版本号
      - 优点：减少锁等待，性能较悲观锁好。
      - 缺点：高并发下仍可能有大量重试。
    - 方案 C：Redis + 原子操作（推荐）
  - 防刷策略
    - 用户限额：每个用户只能领取一次。
    - 验证码 / 登录限制：防止机器人。
    - IP限流：每秒同一IP请求次数限制。
    - 秒杀队列：通过消息队列限流（RabbitMQ、Kafka）。
  - 异步处理+消息队列
    - 高并发时，前端请求可以先进入 消息队列，后台逐个消费写入数据库：
    - 避免数据库瞬间爆炸。
    - 可以做抢券成功后异步发放通知。  

- 服务宕机的情况导致锁无法有效的释放，在生产环境怎么解决这个问题
  - redis
    - 设置过期时间（TTL）
    - 自动续期机制（Redisson 的做法）
      - 如果客户端宕机，续期任务中断，锁自然过期释放。
    - 锁标识验证（防止误删）
  - Zookeeper 分布式锁
    - 宕机或断连时，ZK 自动删除节点；
    - 性能较 Redis 弱；



- 如何来设计实现一个短链接系统
  - 生成短链接
    - 用户输入长 URL，返回一个短 URL。
  - 访问短链接
    - 用户访问短链接，系统重定向到原始长 URL。
  - 短链接生成策略
    - 自增 ID + 编码
      - 每条 URL 对应一个自增整数 ID
      - 将 ID 转为短字符串（通常 62 进制 [a-zA-Z0-9]）
      - 优点：
        - 简单、生成速度快
        - 可顺序增加，方便统计
      - 缺点：
        - 可预测性强
    - 哈希映射
      - 对长 URL 做 MD5 或 SHA256 哈希，再取前 6~8 位作为短码
      - 可防止顺序预测
      - 需要处理哈希冲突（可加随机后缀或重试）
    - 随机生成短码
      - 每次随机生成长度固定的字符串
      - 若已存在，重试
      - 缺点：可能冲突、需要检查数据库唯一性
      - 优点：不可预测
  - 数据库设计
    - short_code 唯一索引 → 快速查找短链接对应长 URL
  - 单机版本
    - 数据库存储映射关系
    - API Server 提供生成短链接和访问短链接接口
  - 高并发分布式版本
    - 缓存短链接映射：访问频繁的短链接先存 Redis，避免频繁访问 DB。
    - 分库分表：根据 ID 或哈希进行水平拆分。
    - 消息队列统计：点击量可以异步写入，避免请求阻塞。
    - 限流


- 如果要做一个抢单系统，你会怎么用 Redisson 来实现？
  - 业务场景分析
    - 同一个订单只能被一个司机/用户成功抢到。
    - 在高并发情况下，要防止：
      - 多个线程同时判断库存（或状态）为“可抢”；
      - 多人同时修改数据库，出现超卖 / 重复抢单。
    - 需要分布式锁（跨节点同步），不能靠 JVM 锁。
  - 核心实现思路
    - 为每个订单加分布式锁
      - 如果业务更看重抢单顺序，用RFairLock
      - 若更看重执行效率，用RLock
      #image("Screenshot_20251023_114033.png")
    -  防止重复抢（同一用户）
      - 如果要防止一个用户抢多个订单，可配合 RSet或 Lua 
    - 限流 
      - RRateLimiter 控制抢单接口 QPS
    