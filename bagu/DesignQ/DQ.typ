= 场景题
- 设计一个广告计费系统，用户曝光点击会产生计费，有每日限额，如何设计，可能遇到什么问题及如何解决？最后一块钱问题怎么解决？
  - 系统要求
    - 曝光和点击触发扣费事件
    - 限额规则
      - 每个广告主每日预算
      - 系统必须保证不超支
    - 高并发要求
      - 每天可能亿级曝光和百万级点击
      - 计费需要实时或者准实时
    - 精度要求
      - 每一笔计费必须精确，最后一块钱不能丢
    - 每日重置
  - 系统设计 
    - 收集曝光/点击事件 → 发送到 消息队列
    - 消费消息队列 → 更新广告消耗
    - 支持每日限额检查
    - 实时计费层（Redis/内存缓存计数）保证快速读取和更新
    - 落地计费层（MySQL / ClickHouse / HBase）存储最终计费记录和统计
    - Redis和MYSQL的同步可以异步
    - Redis counter 每日 0 点重置
  - 问题和解决方案
    - 高并发计数导致超支
      - 使用 Redis 原子操作（HINCRBYFLOAT / Lua 脚本）保证限额不被超越
    - 分布式并发导致超支
      - 全局计数使用 Redis 分布式锁 / 原子脚本
    - 数据落地延迟
      - 批量写数据库，并异步补偿，保证账目最终一致
    - 精度问题（浮点误差）
      - 使用 整数计费（分为最小货币单位，如分） 避免浮点精度问题
    - 宕机导致丢数据
      - 消息队列保证 事件至少一次投递，落地时支持 幂等
  - 最后一块钱问题
    - 当广告剩余预算不足以覆盖一次曝光或点击时，如何处理？
      - 不投放策略
      - 按比例扣费
  

- 秒杀优惠券的核心需求
  - 高并发发放：短时间内可能有成千上万用户请求。
  - 库存控制：优惠券数量有限，不能超发。
  - 防刷机制：防止刷单、恶意抢券。
  - 实时性：用户要尽快知道抢到还是抢不到。
  - 可扩展性：在用户量大时系统仍能稳定。
  - 秒杀抢券的常见策略
    - 方案 A：数据库行锁 (悲观锁)
      - 优点：简单，保证不超发。
      - 缺点：高并发下会成为数据库瓶颈，容易锁表或锁行。
    - 方案 B：乐观锁 + 版本号
      - 优点：减少锁等待，性能较悲观锁好。
      - 缺点：高并发下仍可能有大量重试。
    - 方案 C：Redis + 原子操作（推荐）
  - 防刷策略
    - 用户限额：每个用户只能领取一次。
    - 验证码 / 登录限制：防止机器人。
    - IP限流：每秒同一IP请求次数限制。
    - 秒杀队列：通过消息队列限流（RabbitMQ、Kafka）。
  - 异步处理+消息队列
    - 高并发时，前端请求可以先进入 消息队列，后台逐个消费写入数据库：
    - 避免数据库瞬间爆炸。
    - 可以做抢券成功后异步发放通知。  

- 服务宕机的情况导致锁无法有效的释放，在生产环境怎么解决这个问题
  - redis
    - 设置过期时间（TTL）
    - 自动续期机制（Redisson 的做法）
      - 如果客户端宕机，续期任务中断，锁自然过期释放。
    - 锁标识验证（防止误删）
  - Zookeeper 分布式锁
    - 宕机或断连时，ZK 自动删除节点；
    - 性能较 Redis 弱；