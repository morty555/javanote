= 数据结构
-  了解哪些数据结构？
  - 数组：数组的内存空间是连续的，随机访问的时间复杂度是O1，适用于需要按索引访问元素的场景，但是插入和删除元素较慢，时间复杂度是On
  - 链表：链表是由节点组成，节点之间是分散存储的，内存不连续，每个节点存储数据和指向下一个节点的指针。适用于频繁插入和删除元素的场景，随机访问元素较慢。
  - 栈：栈是一种后进先出的数据结构，只允许在栈顶进行插入和删除操作。
  - 队列：队列是一种先进先出（FIFO）的数据结构，允许在队尾插入元素，在队首删除元素。
  - 树：树是一种非线性数据结构，由节点和边组成，每个节点可以有多个子节点。树适用于表示层次关系的场景，例如文件系统、组织结构等。

- 数组和链表区别是什么？
  - 访问效率：数组可以通过索引直接访问任何位置的元素，访问效率高，时间复杂度为O(1)，而链表需要从头节点开始遍历到目标位置，访问效率较低，时间复杂度为O(n)。
  - 插入和删除操作效率：数组插入和删除操作可能需要移动其他元素，时间复杂度为O(n)，而链表只需要修改指针指向，时间复杂度为O(1)。
  - 缓存命中率：由于数组元素在内存中连续存储，可以提高CPU缓存的命中率，而链表节点不连续存储，可能导致CPU缓存的命中率较低，频繁的缓存失效会影响性能。
  - 应用场景：数组适合静态大小、频繁访问元素的场景，而链表适合动态大小、频繁插入、删除操作的场景

- 为什么数组查询的复杂度为O(1)？
  - 数组必须要内存中一块连续的空间，并且数组中必须存放相同的数据类型
  - 比如我们创建一个长度为 10，数据类型为整型的数组，在内存中的地址是从 1000 开始，由于每个整型数据占据 4 个字节的内存空间，因此整个数组的内存空间地址是 1000～1039，根据这个，我们就可以轻易算出数组中每个数据的内存下标地址。利用这个特性，我们只要知道了数组下标，也就是数据在数组中的位置，比如下标 2，就可以计算得到这个数据在内存中的位置 1008，从而对这个位置的数据 241 进行快速读写访问，时间复杂度为 O(1)。
- 说一下队列和栈的区别
  - 主要区别在于元素的插入和删除方式以及元素的访问顺序。
  - 插入和删除方式：队列：队列采用先进先出（FIFO）的方式，即新元素插入队尾，删除操作发生在队首。
    - 队列：队列采用先进先出（FIFO）的方式，即新元素插入队尾，删除操作发生在队首。
    - 栈：栈采用后进先出（LIFO）的方式，即新元素插入栈顶，删除操作也发生在栈顶。
  - 元素的访问顺序：
    - 队列：队列的元素按照插入的顺序进行访问，先插入的元素先被访问到。
    - 栈：栈的元素按照插入的顺序进行访问，但是最后插入的元素先被访问到。
  - 队列适用于需要按照插入顺序进行处理的场景，例如任务调度；
  - 而栈适用于需要维护最近操作状态的场景，例如函数调用。
- 介绍一下数据结构中的栈？怎么用 java 实现？
  - 栈（stack）是一种特殊的线性数据结构，只能够在一端（即栈顶）进行，采用后进先出原则（LIFO, Last In First Out），基本操作有加入数据（push）和输出数据（pop）两种运算。
  - 在Java中，可以通过多种方式实现栈：
    - 数组实现：适合已知最大容量的情况，但可能会导致栈溢出。
    - 链表实现：动态大小，没有溢出的问题，但需要额外的内存来存储指针。
    - 内置 Stack类：简单易用，适合一般情况，但由于其继承自 Vector，在多线程环境中可能不够高效。
    #image("Screenshot_20250929_150423.png")
- 如何使用两个栈实现队列？
  - 准备两个栈stackPush和stackPop
  - 当需要入队时，将元素压入stackPush
  - 当需要出队时，先判断stackPop是否为空，若不为空，直接弹出栈顶元素；若为空，则将stackPush中的所有元素依次弹出并压入stackPop，然后再弹出stackPop的栈顶元素
  - 当需要查询队首元素时，同样需要先将stackPush中的元素转移到stackPop中，然后取出stackPop的栈顶元素但不弹出。
  - 这种方法的时间复杂度为O(1)的入队操作，均摊时间复杂度为O(1)的出队和查询队首元素操作。

- 常见的队列有哪些及应用场景
  - 顺序队列是利用一组连续的存储单元依次存放从队头到队尾的元素，同时设置两个指针，一个指向队头元素的位置，称为队头指针；另一个指向队尾元素的下一个位置，称为队尾指针。实现简单，空间利用率低，当队尾指针到达数组末尾时，即使前面有空闲空间，也可能无法继续插入元素，造成假溢出。一些简单的、对队列操作不太频繁且数据量相对较小的场景，如学校食堂打饭排队系统，可简单模拟学生排队打饭的过程，新学生在队尾加入，打到饭的学生从队头离开。
  - 链式队列是通过链表来实现的队列，每个节点包含数据域和指针域，指针域指向下一个节点。队头指针指向链表的头节点，队尾指针指向链表的尾节点。插入和删除操作在链表的两端进行，不需要移动元素，操作效率高，可动态分配内存，不存在空间溢出问题，但需要额外的指针空间来存储节点之间的链接关系。常用于处理数据量不确定、需要频繁进行插入和删除操作的场景，如操作系统中的进程调度，新进程可以随时在队尾加入等待队列，就绪的进程从队头取出执行。
  - 循环队列是把顺序队列的存储空间想象成一个首尾相接的圆环，当队尾指针到达数组末尾时，若数组头部还有空闲空间，则将队尾指针重新指向数组头部，继续插入元素。充分利用了数组的空间，避免了顺序队列中的假溢出问题，提高了空间利用率，但实现相对复杂一些，需要处理队头和队尾指针在循环时的特殊情况。常用于数据缓冲区的管理，如音频、视频数据的缓冲，数据以循环的方式存入缓冲区，消费端从队头取出数据进行处理，保证数据的连续和稳定。
  - 双端队列是一种特殊的队列，它允许在队列的两端进行插入和删除操作，既有队头指针又有队尾指针，两端都可以作为队头或队尾进行操作。具有很高的灵活性，可在两端快速插入和删除元素，支持多种操作模式，但实现相对复杂，需要更多的代码来维护两端的操作逻辑。在一些需要频繁在两端进行数据操作的场景中非常有用，如在浏览器的页面浏览历史记录中，用户可以向前和向后浏览页面，新访问的页面可以从队头或队尾插入，浏览过的页面可以从两端删除。
  - 优先级队列中的每个元素都有一个优先级，在插入和删除元素时，会根据元素的优先级来进行操作，优先级高的元素先出队。通常使用堆等数据结构来实现，以保证高效的插入和删除操作。能够快速获取优先级最高（或最低）的元素并进行处理，插入和删除操作的时间复杂度通常为 O (log n)，其中 n 是队列中的元素个数。在任务调度系统中，不同任务可能具有不同的优先级，优先级高的任务需要优先执行，如操作系统中的进程调度，实时性要求高的进程具有较高的优先级，会优先被调度执行。
- 平衡二叉树结构是怎么样的？
  - 