+ java基础面试题
  - 概念
    - java特点
      - 平台无关性
        - java的“编写一次，运行无处不在”哲学是其最大的特点之一。Java编译器将源代码编译成字节码（bytecode），该字节码可以在任何安装了Java虚拟机（JVM）的系统上运行。
      - 面向对象
        - Java是一门严格的面向对象编程语言，几乎一切都是对象。面向对象编程（OOP）特性使得代码更易于维护和重用，包括类，对象，继承，多态，抽象，封装
      - 内存管理
        - Java有自己的垃圾回收机制，自动管理内存和回收不再使用的对象。这样，开发者不需要手动管理内存，从而减少内存泄漏和其他内存相关的问题。
    - Java 的优势和劣势是什么？
      - 优势
        - 跨平台
        - 面向对象
        - 生态系统
        - 自动垃圾回收机制
        - 多线程支持
        - 安全模型，沙箱机制
      - 劣势
        - 性能
        - 语法繁琐
        - 内存消耗
        - 开发效率
        - 面向对象过于严格，简单程序反而麻烦
    - Java为什么是跨平台的？
      - Java 能支持跨平台，主要依赖于 JVM 关系比较大。
      - JVM也是一个软件，不同的平台有不同的版本。我们编写的Java源码，编译后会生成一种 .class 文件，称为字节码文件。Java虚拟机就是负责将字节码文件翻译成特定平台下的机器码然后运行。也就是说，只要在不同平台上安装对应的JVM，就可以运行字节码文件，运行我们编写的Java程序。而这个过程中，我们编写的Java程序没有做任何改变，仅仅是通过JVM这一”中间层““，就能在不同平台上运行，真正实现了”一次编译，到处运行“的目的。
      - JVM是一个”桥梁“，是一个”中间件“，是实现跨平台的关键，Java代码首先被编译成字节码文件，再由JVM将字节码文件翻译成机器语言，从而达到运行Java程序的目的。
      - 编译的结果不是生成机器码，而是生成字节码，字节码不能直接运行，必须通过JVM翻译成机器码才能运行。不同平台下编译生成的字节码是一样的，但是由JVM翻译成的机器码却不一样。
      - 所以，运行Java程序必须有JVM的支持，因为编译的结果不是机器码，必须要经过JVM的再次翻译才能执行。即使你将Java程序打包成可执行文件（例如 .exe），仍然需要JVM的支持。
      - 跨平台的是Java程序，不是JVM。JVM是用C/C++开发的，是编译后的机器码，不能跨平台，不同平台下需要安装不同版本的JVM。
    - JVM、JDK、JRE三者关系？
      - JVM是Java虚拟机，是Java程序运行的环境。它负责将Java字节码（由Java编译器生成）解释或编译成机器码，并执行程序。JVM提供了内存管理、垃圾回收、安全性等功能，使得Java程序具备跨平台性。
      - JDK是Java开发工具包，是开发Java程序所需的工具集合。它包含了JVM、编译器（javac）、调试器（jdb）等开发工具，以及一系列的类库（如Java标准库和开发工具库）。JDK提供了开发、编译、调试和运行Java程序所需的全部工具和环境。
      - JRE是Java运行时环境，是Java程序运行所需的最小环境。它包含了JVM和一组Java类库，用于支持Java程序的执行。    JRE不包含开发工具，只提供Java程序运行所需的运行环境。
      #image("Screenshot_20250901_154807.png")
    - 为什么Java解释和编译都有？
      - 首先在Java经过编译之后生成字节码文件，接下来进入JVM中，就有两个步骤编译和解释。 
        - 编译性：
          - Java源代码首先被编译成字节码，JIT 会把编译过的机器码保存起来,以备下次使用。
        - 解释性：
          - JVM中一个方法调用计数器，当累计计数大于一定值的时候，就使用JIT进行编译生成机器码文件。否则就是用解释器进行解释执行，然后字节码也是经过解释器进行解释运行的。
      - 所以Java既是编译型也是解释性语言，默认采用的是解释器和编译器混合的模式。
      #image("Screenshot_20250901_155408.png")
    - jvm是什么
      - JVM是 java 虚拟机，主要工作是解释自己的指令集（即字节码）并映射到本地的CPU指令集和OS的系统调用。
      - JVM屏蔽了与操作系统平台相关的信息，使得Java程序只需要生成在Java虚拟机上运行的目标代码（字节码），就可在多种平台上不加修改的运行，这也是Java能够“一次编译，到处运行的”原因。
    - 编译型语言和解释型语言的区别？
      - 编译型语言：在程序执行之前，整个源代码会被编译成机器码或者字节码，生成可执行文件。执行时直接运行编译后的代码，速度快，但跨平台性较差。
      - 解释型语言：在程序执行时，逐行解释执行源代码，不生成独立的可执行文件。通常由解释器动态解释并执行代码，跨平台性好，但执行速度相对较慢。
      - 典型的编译型语言如C、C++，典型的解释型语言如Python、JavaScript。
      #image("Screenshot_20250901_161224.png")
      #image("Screenshot_20250901_161233.png")
      - 所以解释性语言是把代码解释成指令直接给cpu或者操作系统执行，只要有对应的解释器就可以在多个平台运行，而编译性语言是编译成机器码执行，而机器码与平台相关，所以跨平台性不好
    -  Python和Java区别是什么？
      - Java是一种已编译的编程语言，Java编译器将源代码编译为字节码，而字节码则由Java虚拟机执行
      - python是一种解释语言，翻译时会在执行程序的同时进行翻译。
  - 数据类型
    - 八种基本的数据类型
      - Java支持数据类型分为两类： 基本数据类型和引用数据类型。
        - 基本数据类型共有8种，可以分为三类：
          - 数值型：整数类型（byte、short、int、long）和浮点类型（float、double）
          - 字符型：char
          - 布尔型：boolean
          #image("Screenshot_20250901_162217.png")
      - Float和Double的最小值和最大值都是以科学记数法的形式输出的，结尾的“E+数字”表示E之前的数字要乘以10的多少倍。比如3.14E3就是3.14×1000=3140
      - Java八种基本数据类型的字节数：1字节(byte、boolean)、 2字节(short、char)、4字节(int、float)、8字节(long、double)
      - 浮点数的默认类型为double（如果需要声明一个常量为float型，则必须要在末尾加上f或F）
      - 整数的默认类型为int（声明Long型在末尾加上l或者L）
      - 八种基本数据类型的包装类：除了char的是Character、int类型的是Integer，其他都是首字母大写
      - char类型是无符号的，不能为负，所以是0开始的
    - int和long是多少位，多少字节的？
      - int类型是 32 位（bit），占 4 个字节（byte），int 是有符号整数类型，其取值范围是从 -2^31 到 2^31-1 。
      - long类型是 64 位，占 8 个字节，long类型也是有符号整数类型，它的取值范围是从 -2^63 到 2^63 -1 ，在处理较大的整数数值时，果int类型的取值范围不够，就需要使用long类型。
    -  long和int可以互转吗 ？
      - 可以的，Java中的long和int可以相互转换。由于long类型的范围比int类型大，因此将int转换为long是安全的，而将long转换为int可能会导致数据丢失或溢出。
      - 将int转换为long可以通过直接赋值或强制类型转换来实现。
      - 将long转换为int需要使用强制类型转换，但需要注意潜在的数据丢失或溢出问题。
      - 在将long转换为int时，如果longValue的值超出了int类型的范围，转换结果将是截断后的低位部分。因此，在进行转换之前，建议先检查longValue的值是否在int类型的范围内，以避免数据丢失或溢出的问题。
    - 数据类型转换方式你知道哪些？
      - 自动类型转换（隐式转换）：当目标类型的范围大于源类型时，Java会自动将源类型转换为目标类型，不需要显式的类型转换。例如，将int转换为long、将float转换为double等。
      - 强制类型转换（显式转换）：当目标类型的范围小于源类型时，需要使用强制类型转换将源类型转换为目标类型。这可能导致数据丢失或溢出。例如，将long转换为int、将double转换为int等。语法为：目标类型 变量名 = (目标类型) 源类型。
      - 字符串转换：Java提供了将字符串表示的数据转换为其他类型数据的方法。例如，将字符串转换为整型int，可以使用Integer.parseInt()方法；将字符串转换为浮点型double，可以使用Double.parseDouble()方法等。
      - 数值之间的转换：Java提供了一些数值类型之间的转换方法，如将整型转换为字符型、将字符型转换为整型等。这些转换方式可以通过类型的包装类来实现，例如Character类、Integer类等提供了相应的转换方法。
    - 类型互转会出现什么问题
      - 当把小范围数据类型赋值给大范围数据类型时，Java 会自动进行类型转换，这种转换一般是安全的。
      - 基本数据类型转换的问题
        - 大范围数据类型赋值给小范围数据类型时，会发生数据数据溢出或者精度损失的问题。
          - 数据溢出：如果大范围数据类型赋值给小范围数据类型时，当目标类型无法容纳原数据时，就会发生数据溢出。比如下面，byte 类型的取值范围是 - 128 到 127。300 的二进制表示为00000001 00101100，强制转换为 byte 类型时，会丢弃高位字节，只保留低位的 8 位00101100，其十进制值为 44。
          ```java 
                    int largeNum = 300;
          byte b = (byte) largeNum; // b的值为44
          ```
        - 精度损失：在进行浮点数类型的转换时，可能会发生精度损失。由于浮点数的表示方式不同，将一个单精度浮点数(float)转换为双精度浮点数(double)时，精度可能会损失，如果 double 转换为 int 也会发生精度损失的问题，如下：
        ```java 
        double d = 3.14;
        int i = (int) d; // i的值为3，小数部分0.14被舍弃
        ```
      - 对象引用转换的问题
        - 向上转型是自动进行的，而且是安全的
        - 但是向下转型需要手动进行，并且存在风险。如果父类对象实际上并不是目标子类的实例，在转型时就会抛出异常：
        - 原因是Java 的对象在运行时会记录其真实类型，当进行向下转型时，Java 会检查对象的实际类型是否与目标类型兼容。如果不兼容，就会抛出ClassCastException。
        - 解决方式是需要使用 instanceof 检查：
        ```java 
        if (animal instanceof Dog) {
    Dog dog = (Dog) animal; // 只有确认animal是Dog的实例时才进行转型
       }
        ```
      - 为什么用bigDecimal 不用double ？
        - double会出现精度丢失的问题，double执行的是二进制浮点运算，二进制有些情况下不能准确的表示一个小数，就像十进制不能准确的表示1/3(1/3=0.3333...)，也就是说二进制表示小数的时候只能够表示能够用1/(2^n)的和的任意组合，但是0.1不能够精确表示，因为它不能够表示成为1/(2^n)的和的形式。
        - 可以看到在Java中进行浮点数运算的时候，会出现丢失精度的问题。那么我们如果在进行商品价格计算的时候，就会出现问题。很有可能造成我们手中有0.06元，却无法购买一个0.05元和一个0.01元的商品。因为如上所示，他们两个的总和为0.060000000000000005。这无疑是一个很严重的问题，尤其是当电商网站的并发量上去的时候，出现的问题将是巨大的。可能会导致无法下单，或者对账出现问题。
        - 而 Decimal 是精确计算 , 所以一般牵扯到金钱的计算 , 都使用 Decimal。
        - 要注意的是，在创建BigDecimal对象时，应该使用字符串作为参数，而不是直接使用浮点数值，以避免浮点数精度丢失。
        ```java
        BigDecimal num1 = new BigDecimal("0.1"); 
        ```
    - 装箱和拆箱是什么？
      - 装箱（Boxing）和拆箱（Unboxing）是将基本数据类型和对应的包装类之间进行转换的过程。
      - 自动装箱主要发生在两种情况，一种是赋值时，另一种是在方法调用的时候。
        - 赋值时
          - 这是最常见的一种情况，在Java 1.5以前我们需要手动地进行转换才行，而现在所有的转换都是由编译器来完成。
                    ```java 
                    ```//before autoboxing
          Integer iObject = Integer.valueOf(3);
          Int iPrimitive = iObject.intValue()

          //after java5
          Integer iObject = 3; //autobxing - primitive to wrapper conversion
          int iPrimitive = iObject; //unboxing - object to primitive conversion
        - 方法调用时
          - 当我们在方法调用时，我们可以传入原始数据值或者对象，同样编译器会帮我们进行转换。
          ```java 
                    public static Integer show(Integer iParam){
            System.out.println("autoboxing example - method invocation i: " + iParam);
            return iParam;
          }

          //autoboxing and unboxing in method invocation
          show(3); //autoboxing
          int result = show(3); //unboxing because return type of method is Integer

          ```
          - show方法接受Integer对象作为参数，当调用show(3)时，会将int值转换成对应的Integer对象，这就是所谓的自动装箱，show方法返回Integer对象，而int result = show(3);中result为int类型，所以这时候发生自动拆箱操作，将show方法的返回的Integer对象转换成int值。
        - 自动装箱的弊端
          - 自动装箱有一个问题，那就是在一个循环中进行自动装箱操作的情况，如下面的例子就会创建多余的对象，影响程序的性能。
          ```java
          Integer sum = 0; for(int i=1000; i<5000; i++){   sum+=i; }  
          ```
          - 上面的代码sum+=i可以看成sum = sum + i，但是+这个操作符不适用于Integer对象，首先sum进行自动拆箱操作，进行数值相加操作，最后发生自动装箱操作转换成Integer对象
          - 由于我们这里声明的sum为Integer类型，在上面的循环中会创建将近4000个无用的Integer对象，在这样庞大的循环中，会降低程序的性能并且加重了垃圾回收的工作量。因此在我们编程时，需要注意到这一点，正确地声明变量类型，避免因为自动装箱引起的性能问题。
    - Java为什么要有Integer？
      - Integer对应是int类型的包装类，就是把int类型包装成Object对象，对象封装有很多好处，可以把属性也就是数据跟处理这些数据的方法结合在一起，比如Integer就有parseInt()等方法来专门处理int型相关的数据。
      - 另一个非常重要的原因就是在Java中绝大部分方法或类都是用来处理类类型对象的，如ArrayList集合类就只能以类作为他的存储对象，而这时如果想把一个int型的数据存入list是不可能的，必须把它包装成类，也就是Integer才能被List所接受。所以Integer的存在是很必要的。
      - 泛型中的应用
        - 在Java中，泛型只能使用引用类型，而不能使用基本类型。因此，如果要在泛型中使用int类型，必须使用Integer包装类。例如，假设我们有一个列表，我们想要将其元素排序，并将排序结果存储在一个新的列表中。如果我们使用基本数据类型int，无法直接使用Collections.sort()方法。但是，如果我们使用Integer包装类，我们就可以轻松地使用Collections.sort()方法。
        ```java 
                List<Integer> list = new ArrayList<>();
        list.add(3);
        list.add(1);
        list.add(2);
        Collections.sort(list);
        System.out.println(list);

        ```
      - 转换中的应用
        - 在Java中，基本类型和引用类型不能直接进行转换，必须使用包装类来实现。例如，将一个int类型的值转换为String类型，必须首先将其转换为Integer类型，然后再转换为String类型。
        ```java
                int i = 10;
        Integer integer = new Integer(i);
        String str = integer.toString();
        System.out.println(str);
 
        ```
      - 集合中的应用
        - Java集合中只能存储对象，而不能存储基本数据类型。因此，如果要将int类型的数据存储在集合中，必须使用Integer包装类。例如，假设我们有一个列表，我们想要计算列表中所有元素的和。如果我们使用基本数据类型int，我们需要使用一个循环来遍历列表，并将每个元素相加。但是，如果我们使用Integer包装类，我们可以直接使用stream()方法来计算所有元素的和。
        ```java
                List<Integer> list = new ArrayList<>();
        list.add(3);
        list.add(1);
        list.add(2);
        int sum = list.stream().mapToInt(Integer::intValue).sum();
        System.out.println(sum);

        ```
    - Integer相比int有什么优点？
      - 基本类型和引用类型：首先，int是一种基本数据类型，而Integer是一种引用类型。基本数据类型是Java中最基本的数据类型，它们是预定义的，不需要实例化就可以使用。而引用类型则需要通过实例化对象来使用。这意味着，使用int来存储一个整数时，不需要任何额外的内存分配，而使用Integer时，必须为对象分配内存。在性能方面，基本数据类型的操作通常比相应的引用类型快。
      - 自动装箱和拆箱：其次，Integer作为int的包装类，它可以实现自动装箱和拆箱。自动装箱是指将基本类型转化为相应的包装类类型，而自动拆箱则是将包装类类型转化为相应的基本类型。这使得Java程序员更加方便地进行数据类型转换。例如，当我们需要将int类型的值赋给Integer变量时，Java可以自动地将int类型转换为Integer类型。同样地，当我们需要将Integer类型的值赋给int变量时，Java可以自动地将Integer类型转换为int类型。
      - 空指针异常：另外，int变量可以直接赋值为0，而Integer变量必须通过实例化对象来赋值。如果对一个未经初始化的Integer变量进行操作，就会出现空指针异常。这是因为它被赋予了null值，而null值是无法进行自动拆箱的。
    - 那为什么还要保留int类型？
      - 包装类是引用类型，对象的引用和对象本身是分开存储的，而对于基本类型数据，变量对应的内存块直接存储数据本身。
      - 因此，基本类型数据在读写效率方面，要比包装类高效。除此之外，在64位JVM上，在开启引用压缩的情况下，一个Integer对象占用16个字节的内存空间，而一个int类型数据只占用4字节的内存空间，前者对空间的占用是后者的4倍。
      - 也就是说，不管是读写效率，还是存储效率，基本类型都比包装类高效。
    - 说一下 integer的缓存
      - Java的Integer类内部实现了一个静态缓存池，用于存储特定范围内的整数值对应的Integer对象。
      - 默认情况下，这个范围是-128至127。当通过Integer.valueOf(int)方法创建一个在这个范围内的整数对象时，并不会每次都生成新的对象实例，而是复用缓存中的现有对象，会直接从内存中取出，不需要新建一个对象
      #image("Screenshot_20250908_144457.png")
      #image("Screenshot_20250908_144514.png")
  - 面向对象 
    - 怎么理解面向对象？简单说说封装继承多态
      - 面向对象是一种编程范式，它将现实世界中的事物抽象为对象，对象具有属性（称为字段或属性）和行为（称为方法）。面向对象编程的设计思想是以对象为中心，通过对象之间的交互来完成程序的功能，具有灵活性和可扩展性，通过封装和继承可以更好地应对需求变化。
      - Java面向对象的三大特性包括：封装、继承、多态：
      - 封装：封装是指将对象的属性（数据）和行为（方法）结合在一起，对外隐藏对象的内部细节，仅通过对象提供的接口与外界交互。封装的目的是增强安全性和简化编程，使得对象更加独立。
      - 继承：继承是一种可以使得子类自动共享父类数据结构和方法的机制。它是代码复用的重要手段，通过继承可以建立类与类之间的层次关系，使得结构更加清晰。
      - 多态：多态是指允许不同类的对象对同一消息作出响应。即同一个接口，使用不同的实例而执行不同操作。多态性可以分为编译时多态（重载）和运行时多态（重写）。它使得程序具有良好的灵活性和扩展性。
    - 多态体现在哪几个方面？
      - 多态在面向对象编程中可以体现在以下几个方面：
        - 方法重载：
          - 方法重载是指同一类中可以有多个同名方法，它们具有不同的参数列表（参数类型、数量或顺序不同）。虽然方法名相同，但根据传入的参数不同，编译器会在编译时确定调用哪个方法。
          - 示例：对于一个 add 方法，可以定义为 add(int a, int b) 和 add(double a, double b)。
        - 方法重写：
          - 方法重写是指子类能够提供对父类中同名方法的具体实现。在运行时，JVM会根据对象的实际类型确定调用哪个版本的方法。这是实现多态的主要方式。
          - 示例：在一个动物类中，定义一个 sound 方法，子类 Dog 可以重写该方法以实现 bark，而 Cat 可以实现 meow。
        - 接口与实现：
          - 多态也体现在接口的使用上，多个类可以实现同一个接口，并且用接口类型的引用来调用这些类的方法。这使得程序在面对不同具体实现时保持一贯的调用方式。
          - 示例：多个类（如 Dog, Cat）都实现了一个 Animal 接口，当用 Animal 类型的引用来调用 makeSound 方法时，会触发对应的实现。
        - 向上转型和向下转型：
          - 在Java中，可以使用父类类型的引用指向子类对象，这是向上转型。通过这种方式，可以在运行时期采用不同的子类实现。
          - 向下转型是将父类引用转回其子类类型，但在执行前需要确认引用实际指向的对象类型以避免 ClassCastException。
    - 多态解决了什么问题？
      - 多态是指子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。多态这种特性也需要编程语言提供特殊的语法机制来实现，比如继承、接口类。
      - 多态可以提高代码的扩展性和复用性，是很多设计模式、设计原则、编程技巧的代码实现基础。比如策略模式、基于接口而非实现编程、依赖倒置原则、里式替换原则、利用多态去掉冗长的 if-else 语句等等
    - 面向对象的设计原则你知道有哪些吗
      - 单一职责原则（SRP）：一个类应该只有一个引起它变化的原因，即一个类应该只负责一项职责。例子：考虑一个员工类，它应该只负责管理员工信息，而不应负责其他无关工作。
      - 开放封闭原则（OCP）：软件实体应该对扩展开放，对修改封闭。例子：通过制定接口来实现这一原则，比如定义一个图形类，然后让不同类型的图形继承这个类，而不需要修改图形类本身。
      - 里氏替换原则（LSP）：子类对象应该能够替换掉所有父类对象。例子：一个正方形是一个矩形，但如果修改一个矩形的高度和宽度时，正方形的行为应该如何改变就是一个违反里氏替换原则的例子。
      - 接口隔离原则（ISP）：客户端不应该依赖那些它不需要的接口，即接口应该小而专。例子：通过接口抽象层来实现底层和高层模块之间的解耦，比如使用依赖注入。
      - 依赖倒置原则（DIP）：高层模块不应该依赖低层模块，二者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。例子：如果一个公司类包含部门类，应该考虑使用合成/聚合关系，而不是将公司类继承自部门类。
      - 最少知识原则 (Law of Demeter)：一个对象应当对其他对象有最少的了解，只与其直接的朋友交互。
    - 重载与重写有什么区别？
      - 重载（Overloading）指的是在同一个类中，可以有多个同名方法，它们具有不同的参数列表（参数类型、参数个数或参数顺序不同），编译器根据调用时的参数类型来决定调用哪个方法。（返回类型不可以作为重载的区分条件）
      - 重写（Overriding）指的是子类可以重新定义父类中的方法，方法名、参数列表和返回类型必须与父类中的方法一致，通过override注解来明确表示这是对父类方法的重写。
      - 重载是指在同一个类中定义多个同名方法，而重写是指子类重新定义父类中的方法。
    - 抽象类和普通类区别？
      - 实例化：普通类可以直接实例化对象，而抽象类不能被实例化，只能被继承。
      - 方法实现：普通类中的方法可以有具体的实现，而抽象类中的方法可以有实现也可以没有实现。
      - 继承：一个类可以继承一个普通类，而且可以继承多个接口；而一个类只能继承一个抽象类，但可以同时实现多个接口。
      - 实现限制：普通类可以被其他类继承和使用，而抽象类一般用于作为基类，被其他类继承和扩展使用。
    - Java抽象类和接口的区别是什么？



     