+ java基础面试题
  - 概念
    - java特点
      - 平台无关性
        - java的“编写一次，运行无处不在”哲学是其最大的特点之一。Java编译器将源代码编译成字节码（bytecode），该字节码可以在任何安装了Java虚拟机（JVM）的系统上运行。
      - 面向对象
        - Java是一门严格的面向对象编程语言，几乎一切都是对象。面向对象编程（OOP）特性使得代码更易于维护和重用，包括类，对象，继承，多态，抽象，封装
      - 内存管理
        - Java有自己的垃圾回收机制，自动管理内存和回收不再使用的对象。这样，开发者不需要手动管理内存，从而减少内存泄漏和其他内存相关的问题。
    - Java 的优势和劣势是什么？
      - 优势
        - 跨平台
        - 面向对象
        - 生态系统
        - 自动垃圾回收机制
        - 多线程支持
        - 安全模型，沙箱机制
      - 劣势
        - 性能
        - 语法繁琐
        - 内存消耗
        - 开发效率
        - 面向对象过于严格，简单程序反而麻烦
    - Java为什么是跨平台的？
      - Java 能支持跨平台，主要依赖于 JVM 关系比较大。
      - JVM也是一个软件，不同的平台有不同的版本。我们编写的Java源码，编译后会生成一种 .class 文件，称为字节码文件。Java虚拟机就是负责将字节码文件翻译成特定平台下的机器码然后运行。也就是说，只要在不同平台上安装对应的JVM，就可以运行字节码文件，运行我们编写的Java程序。而这个过程中，我们编写的Java程序没有做任何改变，仅仅是通过JVM这一”中间层““，就能在不同平台上运行，真正实现了”一次编译，到处运行“的目的。
      - JVM是一个”桥梁“，是一个”中间件“，是实现跨平台的关键，Java代码首先被编译成字节码文件，再由JVM将字节码文件翻译成机器语言，从而达到运行Java程序的目的。
      - 编译的结果不是生成机器码，而是生成字节码，字节码不能直接运行，必须通过JVM翻译成机器码才能运行。不同平台下编译生成的字节码是一样的，但是由JVM翻译成的机器码却不一样。
      - 所以，运行Java程序必须有JVM的支持，因为编译的结果不是机器码，必须要经过JVM的再次翻译才能执行。即使你将Java程序打包成可执行文件（例如 .exe），仍然需要JVM的支持。
      - 跨平台的是Java程序，不是JVM。JVM是用C/C++开发的，是编译后的机器码，不能跨平台，不同平台下需要安装不同版本的JVM。
    - JVM、JDK、JRE三者关系？
      - JVM是Java虚拟机，是Java程序运行的环境。它负责将Java字节码（由Java编译器生成）解释或编译成机器码，并执行程序。JVM提供了内存管理、垃圾回收、安全性等功能，使得Java程序具备跨平台性。
      - JDK是Java开发工具包，是开发Java程序所需的工具集合。它包含了JVM、编译器（javac）、调试器（jdb）等开发工具，以及一系列的类库（如Java标准库和开发工具库）。JDK提供了开发、编译、调试和运行Java程序所需的全部工具和环境。
      - JRE是Java运行时环境，是Java程序运行所需的最小环境。它包含了JVM和一组Java类库，用于支持Java程序的执行。    JRE不包含开发工具，只提供Java程序运行所需的运行环境。
      #image("Screenshot_20250901_154807.png")
    - 为什么Java解释和编译都有？
      - 首先在Java经过编译之后生成字节码文件，接下来进入JVM中，就有两个步骤编译和解释。 
        - 编译性：
          - Java源代码首先被编译成字节码，JIT 会把编译过的机器码保存起来,以备下次使用。
        - 解释性：
          - JVM中一个方法调用计数器，当累计计数大于一定值的时候，就使用JIT进行编译生成机器码文件。否则就是用解释器进行解释执行，然后字节码也是经过解释器进行解释运行的。
      - 所以Java既是编译型也是解释性语言，默认采用的是解释器和编译器混合的模式。
      #image("Screenshot_20250901_155408.png")
    - jvm是什么
      - JVM是 java 虚拟机，主要工作是解释自己的指令集（即字节码）并映射到本地的CPU指令集和OS的系统调用。
      - JVM屏蔽了与操作系统平台相关的信息，使得Java程序只需要生成在Java虚拟机上运行的目标代码（字节码），就可在多种平台上不加修改的运行，这也是Java能够“一次编译，到处运行的”原因。
    - 编译型语言和解释型语言的区别？
      - 编译型语言：在程序执行之前，整个源代码会被编译成机器码或者字节码，生成可执行文件。执行时直接运行编译后的代码，速度快，但跨平台性较差。
      - 解释型语言：在程序执行时，逐行解释执行源代码，不生成独立的可执行文件。通常由解释器动态解释并执行代码，跨平台性好，但执行速度相对较慢。
      - 典型的编译型语言如C、C++，典型的解释型语言如Python、JavaScript。
      #image("Screenshot_20250901_161224.png")
      #image("Screenshot_20250901_161233.png")
      - 所以解释性语言是把代码解释成指令直接给cpu或者操作系统执行，只要有对应的解释器就可以在多个平台运行，而编译性语言是编译成机器码执行，而机器码与平台相关，所以跨平台性不好
    -  Python和Java区别是什么？
      - Java是一种已编译的编程语言，Java编译器将源代码编译为字节码，而字节码则由Java虚拟机执行
      - python是一种解释语言，翻译时会在执行程序的同时进行翻译。
  - 数据类型
    - 八种基本的数据类型
      - Java支持数据类型分为两类： 基本数据类型和引用数据类型。
        - 基本数据类型共有8种，可以分为三类：
          - 数值型：整数类型（byte、short、int、long）和浮点类型（float、double）
          - 字符型：char
          - 布尔型：boolean
          #image("Screenshot_20250901_162217.png")
      - Float和Double的最小值和最大值都是以科学记数法的形式输出的，结尾的“E+数字”表示E之前的数字要乘以10的多少倍。比如3.14E3就是3.14×1000=3140
      - Java八种基本数据类型的字节数：1字节(byte、boolean)、 2字节(short、char)、4字节(int、float)、8字节(long、double)
      - 浮点数的默认类型为double（如果需要声明一个常量为float型，则必须要在末尾加上f或F）
      - 整数的默认类型为int（声明Long型在末尾加上l或者L）
      - 八种基本数据类型的包装类：除了char的是Character、int类型的是Integer，其他都是首字母大写
      - char类型是无符号的，不能为负，所以是0开始的
    - int和long是多少位，多少字节的？
      - int类型是 32 位（bit），占 4 个字节（byte），int 是有符号整数类型，其取值范围是从 -2^31 到 2^31-1 。
      - long类型是 64 位，占 8 个字节，long类型也是有符号整数类型，它的取值范围是从 -2^63 到 2^63 -1 ，在处理较大的整数数值时，果int类型的取值范围不够，就需要使用long类型。
    -  long和int可以互转吗 ？
      - 可以的，Java中的long和int可以相互转换。由于long类型的范围比int类型大，因此将int转换为long是安全的，而将long转换为int可能会导致数据丢失或溢出。
      - 将int转换为long可以通过直接赋值或强制类型转换来实现。
      - 将long转换为int需要使用强制类型转换，但需要注意潜在的数据丢失或溢出问题。
      - 在将long转换为int时，如果longValue的值超出了int类型的范围，转换结果将是截断后的低位部分。因此，在进行转换之前，建议先检查longValue的值是否在int类型的范围内，以避免数据丢失或溢出的问题。
    - 数据类型转换方式你知道哪些？
      - 自动类型转换（隐式转换）：当目标类型的范围大于源类型时，Java会自动将源类型转换为目标类型，不需要显式的类型转换。例如，将int转换为long、将float转换为double等。
      - 强制类型转换（显式转换）：当目标类型的范围小于源类型时，需要使用强制类型转换将源类型转换为目标类型。这可能导致数据丢失或溢出。例如，将long转换为int、将double转换为int等。语法为：目标类型 变量名 = (目标类型) 源类型。
      - 字符串转换：Java提供了将字符串表示的数据转换为其他类型数据的方法。例如，将字符串转换为整型int，可以使用Integer.parseInt()方法；将字符串转换为浮点型double，可以使用Double.parseDouble()方法等。
      - 数值之间的转换：Java提供了一些数值类型之间的转换方法，如将整型转换为字符型、将字符型转换为整型等。这些转换方式可以通过类型的包装类来实现，例如Character类、Integer类等提供了相应的转换方法。
    - 类型互转会出现什么问题
      - 当把小范围数据类型赋值给大范围数据类型时，Java 会自动进行类型转换，这种转换一般是安全的。
      - 基本数据类型转换的问题
        - 大范围数据类型赋值给小范围数据类型时，会发生数据数据溢出或者精度损失的问题。
          - 数据溢出：如果大范围数据类型赋值给小范围数据类型时，当目标类型无法容纳原数据时，就会发生数据溢出。比如下面，byte 类型的取值范围是 - 128 到 127。300 的二进制表示为00000001 00101100，强制转换为 byte 类型时，会丢弃高位字节，只保留低位的 8 位00101100，其十进制值为 44。
          ```java 
                    int largeNum = 300;
          byte b = (byte) largeNum; // b的值为44
          ```
        - 精度损失：在进行浮点数类型的转换时，可能会发生精度损失。由于浮点数的表示方式不同，将一个单精度浮点数(float)转换为双精度浮点数(double)时，精度可能会损失，如果 double 转换为 int 也会发生精度损失的问题，如下：
        ```java 
        double d = 3.14;
        int i = (int) d; // i的值为3，小数部分0.14被舍弃
        ```
      - 对象引用转换的问题
        - 向上转型是自动进行的，而且是安全的
        - 但是向下转型需要手动进行，并且存在风险。如果父类对象实际上并不是目标子类的实例，在转型时就会抛出异常：
        - 原因是Java 的对象在运行时会记录其真实类型，当进行向下转型时，Java 会检查对象的实际类型是否与目标类型兼容。如果不兼容，就会抛出ClassCastException。
        - 解决方式是需要使用 instanceof 检查：
        ```java 
        if (animal instanceof Dog) {
    Dog dog = (Dog) animal; // 只有确认animal是Dog的实例时才进行转型
       }
        ```
      - 为什么用bigDecimal 不用double ？
        - double会出现精度丢失的问题，double执行的是二进制浮点运算，二进制有些情况下不能准确的表示一个小数，就像十进制不能准确的表示1/3(1/3=0.3333...)，也就是说二进制表示小数的时候只能够表示能够用1/(2^n)的和的任意组合，但是0.1不能够精确表示，因为它不能够表示成为1/(2^n)的和的形式。
        - 可以看到在Java中进行浮点数运算的时候，会出现丢失精度的问题。那么我们如果在进行商品价格计算的时候，就会出现问题。很有可能造成我们手中有0.06元，却无法购买一个0.05元和一个0.01元的商品。因为如上所示，他们两个的总和为0.060000000000000005。这无疑是一个很严重的问题，尤其是当电商网站的并发量上去的时候，出现的问题将是巨大的。可能会导致无法下单，或者对账出现问题。
        - 而 Decimal 是精确计算 , 所以一般牵扯到金钱的计算 , 都使用 Decimal。
        - 要注意的是，在创建BigDecimal对象时，应该使用字符串作为参数，而不是直接使用浮点数值，以避免浮点数精度丢失。
        ```java
        BigDecimal num1 = new BigDecimal("0.1"); 
        ```
    - 装箱和拆箱是什么？
      - 装箱（Boxing）和拆箱（Unboxing）是将基本数据类型和对应的包装类之间进行转换的过程。
      - 自动装箱主要发生在两种情况，一种是赋值时，另一种是在方法调用的时候。
        - 赋值时
          - 这是最常见的一种情况，在Java 1.5以前我们需要手动地进行转换才行，而现在所有的转换都是由编译器来完成。
                    ```java 
                    ```//before autoboxing
          Integer iObject = Integer.valueOf(3);
          Int iPrimitive = iObject.intValue()

          //after java5
          Integer iObject = 3; //autobxing - primitive to wrapper conversion
          int iPrimitive = iObject; //unboxing - object to primitive conversion
        - 方法调用时
          - 当我们在方法调用时，我们可以传入原始数据值或者对象，同样编译器会帮我们进行转换。
          ```java 
                    public static Integer show(Integer iParam){
            System.out.println("autoboxing example - method invocation i: " + iParam);
            return iParam;
          }

          //autoboxing and unboxing in method invocation
          show(3); //autoboxing
          int result = show(3); //unboxing because return type of method is Integer

          ```
          - show方法接受Integer对象作为参数，当调用show(3)时，会将int值转换成对应的Integer对象，这就是所谓的自动装箱，show方法返回Integer对象，而int result = show(3);中result为int类型，所以这时候发生自动拆箱操作，将show方法的返回的Integer对象转换成int值。
        - 自动装箱的弊端
          - 自动装箱有一个问题，那就是在一个循环中进行自动装箱操作的情况，如下面的例子就会创建多余的对象，影响程序的性能。
          ```java
          Integer sum = 0; for(int i=1000; i<5000; i++){   sum+=i; }  
          ```
          - 上面的代码sum+=i可以看成sum = sum + i，但是+这个操作符不适用于Integer对象，首先sum进行自动拆箱操作，进行数值相加操作，最后发生自动装箱操作转换成Integer对象
          - 由于我们这里声明的sum为Integer类型，在上面的循环中会创建将近4000个无用的Integer对象，在这样庞大的循环中，会降低程序的性能并且加重了垃圾回收的工作量。因此在我们编程时，需要注意到这一点，正确地声明变量类型，避免因为自动装箱引起的性能问题。
    - Java为什么要有Integer？
      - Integer对应是int类型的包装类，就是把int类型包装成Object对象，对象封装有很多好处，可以把属性也就是数据跟处理这些数据的方法结合在一起，比如Integer就有parseInt()等方法来专门处理int型相关的数据。
      - 另一个非常重要的原因就是在Java中绝大部分方法或类都是用来处理类类型对象的，如ArrayList集合类就只能以类作为他的存储对象，而这时如果想把一个int型的数据存入list是不可能的，必须把它包装成类，也就是Integer才能被List所接受。所以Integer的存在是很必要的。
      - 泛型中的应用
        - 在Java中，泛型只能使用引用类型，而不能使用基本类型。因此，如果要在泛型中使用int类型，必须使用Integer包装类。例如，假设我们有一个列表，我们想要将其元素排序，并将排序结果存储在一个新的列表中。如果我们使用基本数据类型int，无法直接使用Collections.sort()方法。但是，如果我们使用Integer包装类，我们就可以轻松地使用Collections.sort()方法。
        ```java 
                List<Integer> list = new ArrayList<>();
        list.add(3);
        list.add(1);
        list.add(2);
        Collections.sort(list);
        System.out.println(list);

        ```
      - 转换中的应用
        - 在Java中，基本类型和引用类型不能直接进行转换，必须使用包装类来实现。例如，将一个int类型的值转换为String类型，必须首先将其转换为Integer类型，然后再转换为String类型。
        ```java
                int i = 10;
        Integer integer = new Integer(i);
        String str = integer.toString();
        System.out.println(str);
 
        ```
      - 集合中的应用
        - Java集合中只能存储对象，而不能存储基本数据类型。因此，如果要将int类型的数据存储在集合中，必须使用Integer包装类。例如，假设我们有一个列表，我们想要计算列表中所有元素的和。如果我们使用基本数据类型int，我们需要使用一个循环来遍历列表，并将每个元素相加。但是，如果我们使用Integer包装类，我们可以直接使用stream()方法来计算所有元素的和。
        ```java
                List<Integer> list = new ArrayList<>();
        list.add(3);
        list.add(1);
        list.add(2);
        int sum = list.stream().mapToInt(Integer::intValue).sum();
        System.out.println(sum);

        ```
    - Integer相比int有什么优点？
      - 基本类型和引用类型：首先，int是一种基本数据类型，而Integer是一种引用类型。基本数据类型是Java中最基本的数据类型，它们是预定义的，不需要实例化就可以使用。而引用类型则需要通过实例化对象来使用。这意味着，使用int来存储一个整数时，不需要任何额外的内存分配，而使用Integer时，必须为对象分配内存。在性能方面，基本数据类型的操作通常比相应的引用类型快。
      - 自动装箱和拆箱：其次，Integer作为int的包装类，它可以实现自动装箱和拆箱。自动装箱是指将基本类型转化为相应的包装类类型，而自动拆箱则是将包装类类型转化为相应的基本类型。这使得Java程序员更加方便地进行数据类型转换。例如，当我们需要将int类型的值赋给Integer变量时，Java可以自动地将int类型转换为Integer类型。同样地，当我们需要将Integer类型的值赋给int变量时，Java可以自动地将Integer类型转换为int类型。
      - 空指针异常：另外，int变量可以直接赋值为0，而Integer变量必须通过实例化对象来赋值。如果对一个未经初始化的Integer变量进行操作，就会出现空指针异常。这是因为它被赋予了null值，而null值是无法进行自动拆箱的。
    - 那为什么还要保留int类型？
      - 包装类是引用类型，对象的引用和对象本身是分开存储的，而对于基本类型数据，变量对应的内存块直接存储数据本身。
      - 因此，基本类型数据在读写效率方面，要比包装类高效。除此之外，在64位JVM上，在开启引用压缩的情况下，一个Integer对象占用16个字节的内存空间，而一个int类型数据只占用4字节的内存空间，前者对空间的占用是后者的4倍。
      - 也就是说，不管是读写效率，还是存储效率，基本类型都比包装类高效。
    - 说一下 integer的缓存
      - Java的Integer类内部实现了一个静态缓存池，用于存储特定范围内的整数值对应的Integer对象。
      - 默认情况下，这个范围是-128至127。当通过Integer.valueOf(int)方法创建一个在这个范围内的整数对象时，并不会每次都生成新的对象实例，而是复用缓存中的现有对象，会直接从内存中取出，不需要新建一个对象
      #image("Screenshot_20250908_144457.png")
      #image("Screenshot_20250908_144514.png")
  - 面向对象 
    - 怎么理解面向对象？简单说说封装继承多态
      - 面向对象是一种编程范式，它将现实世界中的事物抽象为对象，对象具有属性（称为字段或属性）和行为（称为方法）。面向对象编程的设计思想是以对象为中心，通过对象之间的交互来完成程序的功能，具有灵活性和可扩展性，通过封装和继承可以更好地应对需求变化。
      - Java面向对象的三大特性包括：封装、继承、多态：
      - 封装：封装是指将对象的属性（数据）和行为（方法）结合在一起，对外隐藏对象的内部细节，仅通过对象提供的接口与外界交互。封装的目的是增强安全性和简化编程，使得对象更加独立。
      - 继承：继承是一种可以使得子类自动共享父类数据结构和方法的机制。它是代码复用的重要手段，通过继承可以建立类与类之间的层次关系，使得结构更加清晰。
      - 多态：多态是指允许不同类的对象对同一消息作出响应。即同一个接口，使用不同的实例而执行不同操作。多态性可以分为编译时多态（重载）和运行时多态（重写）。它使得程序具有良好的灵活性和扩展性。
    - 多态体现在哪几个方面？
      - 多态在面向对象编程中可以体现在以下几个方面：
        - 方法重载：
          - 方法重载是指同一类中可以有多个同名方法，它们具有不同的参数列表（参数类型、数量或顺序不同）。虽然方法名相同，但根据传入的参数不同，编译器会在编译时确定调用哪个方法。
          - 示例：对于一个 add 方法，可以定义为 add(int a, int b) 和 add(double a, double b)。
        - 方法重写：
          - 方法重写是指子类能够提供对父类中同名方法的具体实现。在运行时，JVM会根据对象的实际类型确定调用哪个版本的方法。这是实现多态的主要方式。
          - 示例：在一个动物类中，定义一个 sound 方法，子类 Dog 可以重写该方法以实现 bark，而 Cat 可以实现 meow。
        - 接口与实现：
          - 多态也体现在接口的使用上，多个类可以实现同一个接口，并且用接口类型的引用来调用这些类的方法。这使得程序在面对不同具体实现时保持一贯的调用方式。
          - 示例：多个类（如 Dog, Cat）都实现了一个 Animal 接口，当用 Animal 类型的引用来调用 makeSound 方法时，会触发对应的实现。
        - 向上转型和向下转型：
          - 在Java中，可以使用父类类型的引用指向子类对象，这是向上转型。通过这种方式，可以在运行时期采用不同的子类实现。
          - 向下转型是将父类引用转回其子类类型，但在执行前需要确认引用实际指向的对象类型以避免 ClassCastException。
    - 多态解决了什么问题？
      - 多态是指子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。多态这种特性也需要编程语言提供特殊的语法机制来实现，比如继承、接口类。
      - 多态可以提高代码的扩展性和复用性，是很多设计模式、设计原则、编程技巧的代码实现基础。比如策略模式、基于接口而非实现编程、依赖倒置原则、里式替换原则、利用多态去掉冗长的 if-else 语句等等
    - 面向对象的设计原则你知道有哪些吗
      - 单一职责原则（SRP）：一个类应该只有一个引起它变化的原因，即一个类应该只负责一项职责。例子：考虑一个员工类，它应该只负责管理员工信息，而不应负责其他无关工作。
      - 开放封闭原则（OCP）：软件实体应该对扩展开放，对修改封闭。例子：通过制定接口来实现这一原则，比如定义一个图形类，然后让不同类型的图形继承这个类，而不需要修改图形类本身。
      - 里氏替换原则（LSP）：子类对象应该能够替换掉所有父类对象。例子：一个正方形是一个矩形，但如果修改一个矩形的高度和宽度时，正方形的行为应该如何改变就是一个违反里氏替换原则的例子。
      - 接口隔离原则（ISP）：客户端不应该依赖那些它不需要的接口，即接口应该小而专。例子：通过接口抽象层来实现底层和高层模块之间的解耦，比如使用依赖注入。
      - 依赖倒置原则（DIP）：高层模块不应该依赖低层模块，二者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。例子：如果一个公司类包含部门类，应该考虑使用合成/聚合关系，而不是将公司类继承自部门类。
      - 最少知识原则 (Law of Demeter)：一个对象应当对其他对象有最少的了解，只与其直接的朋友交互。
    - 重载与重写有什么区别？
      - 重载（Overloading）指的是在同一个类中，可以有多个同名方法，它们具有不同的参数列表（参数类型、参数个数或参数顺序不同），编译器根据调用时的参数类型来决定调用哪个方法。（返回类型不可以作为重载的区分条件）
      - 重写（Overriding）指的是子类可以重新定义父类中的方法，方法名、参数列表和返回类型必须与父类中的方法一致，通过override注解来明确表示这是对父类方法的重写。
      - 重载是指在同一个类中定义多个同名方法，而重写是指子类重新定义父类中的方法。
    - 抽象类和普通类区别？
      - 实例化：普通类可以直接实例化对象，而抽象类不能被实例化，只能被继承。
      - 方法实现：普通类中的方法可以有具体的实现，而抽象类中的方法可以有实现也可以没有实现。
      - 继承：一个类可以继承一个普通类，而且可以继承多个接口；而一个类只能继承一个抽象类，但可以同时实现多个接口。
      - 实现限制：普通类可以被其他类继承和使用，而抽象类一般用于作为基类，被其他类继承和扩展使用。
    - Java抽象类和接口的区别是什么？
      - 两者的特点：
        - 抽象类用于描述类的共同特性和行为，可以有成员变量、构造方法和具体方法。适用于有明显继承关系的场景。
        - 接口用于定义行为规范，可以多实现，只能有常量和抽象方法（Java 8 以后可以有默认方法和静态方法）。适用于定义类的能力或功能。
      - 两者的区别：
        - 实现方式：实现接口的关键字为implements，继承抽象类的关键字为extends。一个类可以实现多个接口，但一个类只能继承一个抽象类。所以，使用接口可以间接地实现多重继承。
        - 方法方式：接口只有定义，不能有方法的实现，java 1.8中可以定义default方法体，而抽象类可以有定义与实现，方法可在抽象类中实现。
        - 访问修饰符：接口成员变量默认为public static final，必须赋初值，不能被修改；其所有的成员方法都是public、abstract的。抽象类中成员变量默认default，可在子类中被重新定义，也可被重新赋值；抽象方法被abstract修饰，不能被private、static、synchronized和native等修饰，必须以分号结尾，不带花括号。
        - 变量：抽象类可以包含实例变量和静态变量，而接口只能包含常量（即静态常量）。
    -  抽象类能加final修饰吗？
      - 不能，Java中的抽象类是用来被继承的，而final修饰符用于禁止类被继承或方法被重写，因此，抽象类和final修饰符是互斥的，不能同时使用。
    - 接口里面可以定义哪些方法？
      - 抽象方法
        - 抽象方法是接口的核心部分，所有实现接口的类都必须实现这些方法。抽象方法默认是 public 和 abstract，这些修饰符可以省略。
      - 默认方法
        - 默认方法是在 Java 8 中引入的，允许接口提供具体实现。实现类可以选择重写默认方法。
      - 静态方法
        - 静态方法也是在 Java 8 中引入的，它们属于接口本身，可以通过接口名直接调用，而不需要实现类的对象。
      - 私有方法
        - 私有方法是在 Java 9 中引入的，用于在接口中为默认方法或其他私有方法提供辅助功能。这些方法不能被实现类访问，只能在接口内部使用。
    - 抽象类可以被实例化吗？
      - 在Java中，抽象类本身不能被实例化。
      - 这意味着不能使用new关键字直接创建一个抽象类的对象。抽象类的存在主要是为了被继承，它通常包含一个或多个抽象方法（由abstract关键字修饰且无方法体的方法），这些方法需要在子类中被实现。
      - 抽象类可以有构造器，这些构造器在子类实例化时会被调用，以便进行必要的初始化工作。然而，这个过程并不是直接实例化抽象类，而是创建了子类的实例，间接地使用了抽象类的构造器。
      - 在这个例子中，ConcreteClass继承了AbstractClass并实现了抽象方法abstractMethod()。当我们创建ConcreteClass的实例时，AbstractClass的构造器被调用，但这并不意味着AbstractClass被实例化；实际上，我们创建的是ConcreteClass的一个对象。
    - 接口可以包含构造函数吗？
      - 在接口中，不可以有构造方法,在接口里写入构造方法时，编译器提示：Interfaces cannot have constructors，因为接口不会有自己的实例的，所以不需要有构造函数。
      - 为什么呢？构造函数就是初始化class的属性或者方法，在new的一瞬间自动调用，那么问题来了Java的接口，都不能new 那么要构造函数干嘛呢？根本就没法调用
    - 解释Java中的静态变量和静态方法
      - 在Java中，静态变量和静态方法是与类本身关联的，而不是与类的实例（对象）关联。它们在内存中只存在一份，可以被类的所有实例共享。
      - 静态变量
        - 静态变量（也称为类变量）是在类中使用static关键字声明的变量。它们属于类而不是任何具体的对象。主要的特点：
          - 共享性：所有该类的实例共享同一个静态变量。如果一个实例修改了静态变量的值，其他实例也会看到这个更改。
          - 初始化：静态变量在类被加载时初始化，只会对其进行一次分配内存。
          - 访问方式：静态变量可以直接通过类名访问，也可以通过实例访问，但推荐使用类名。
      - 静态方法
        - 静态方法是在类中使用static关键字声明的方法。类似于静态变量，静态方法也属于类，而不是任何具体的对象。主要的特点：
          - 无实例依赖：静态方法可以在没有创建类实例的情况下调用。对于静态方法来说，不能直接访问非静态的成员变量或方法，因为静态方法没有上下文的实例。
          - 访问静态成员：静态方法可以直接调用其他静态变量和静态方法，但不能直接访问非静态成员。
          - 多态性：静态方法不支持重写（Override），但可以被隐藏（Hide）。
      - 使用场景
        - 静态变量：常用于需要在所有对象间共享的数据，如计数器、常量等。
        - 静态方法：常用于助手方法（utility methods）、获取类级别的信息或者是没有依赖于实例的数据处理。
    - 非静态内部类和静态内部类的区别？
      - 非静态内部类依赖于外部类的实例，而静态内部类不依赖于外部类的实例。
      - 非静态内部类可以访问外部类的实例变量和方法，而静态内部类只能访问外部类的静态成员。
      - 非静态内部类不能定义静态成员，而静态内部类可以定义静态成员。
      - 非静态内部类在外部类实例化后才能实例化，而静态内部类可以独立实例化。
      - 非静态内部类可以访问外部类的私有成员，而静态内部类不能直接访问外部类的私有成员，需要通过实例化外部类来访问。
    - 非静态内部类可以直接访问外部方法，编译器是怎么做到的？
      - 非静态内部类可以直接访问外部方法是因为编译器在生成字节码时会为非静态内部类维护一个指向外部类实例的引用。
      - 这个引用使得非静态内部类能够访问外部类的实例变量和方法。编译器会在生成非静态内部类的构造方法时，将外部类实例作为参数传入，并在内部类的实例化过程中建立外部类实例与内部类实例之间的联系，从而实现直接访问外部方法的功能。
  - 关键字
    - Java 中 final 作用是什么？
      - final关键字主要有以下三个方面的作用：用于修饰类、方法和变量。
        - 修饰类：当final修饰一个类时，表示这个类不能被继承，是类继承体系中的最终形态。例如，Java 中的String类就是用final修饰的，这保证了String类的不可变性和安全性，防止其他类通过继承来改变String类的行为和特性。
        - 修饰方法：用final修饰的方法不能在子类中被重写。比如，java.lang.Object类中的getClass方法就是final的，因为这个方法的行为是由 Java 虚拟机底层实现来保证的，不应该被子类修改。
        - 修饰变量：当final修饰基本数据类型的变量时，该变量一旦被赋值就不能再改变。例如，final int num = 10;，这里的num就是一个常量，不能再对其进行重新赋值操作，否则会导致编译错误。对于引用数据类型，final修饰意味着这个引用变量不能再指向其他对象，但对象本身的内容是可以改变的。例如，final StringBuilder sb = new StringBuilder("Hello");，不能让sb再指向其他StringBuilder对象，但可以通过sb.append(" World");来修改字符串的内容。
    - Java 中 static的作用是什么？
      - static 关键字主要用于修饰类的成员（变量、方法、代码块）和内部类，其核心作用是将成员与类本身关联，而非与类的实例（对象）关联。具体作用如下：
        - 修饰变量
          - 被 static 修饰的变量属于类本身，而非类的某个实例。所有对象共享同一份静态变量，内存中只存在一份副本。可以通过 类名.变量名 直接访问，无需创建对象（也可通过对象访问，但不推荐）。
          - 通常用于存储所有对象共享的数据，如常量、计数器等。
        - 修饰方法
          - 静态方法属于类，不属于任何实例，因此不能直接访问类中的非静态成员（变量 / 方法）（因为非静态成员依赖于对象存在），但可以访问静态成员。通过 类名.方法名 直接调用，无需创建对象。 
          - 通常用于工具类方法（如 Math.random()）、工厂方法等，不需要依赖对象状态即可完成操作。
        - 修饰代码块
          - 静态代码块在类加载时执行，且只执行一次（优于对象构造方法），用于初始化静态变量或执行类级别的预处理操作。
          - 多个静态代码块按定义顺序执行，且先于非静态代码块和构造方法。
        - 修饰内部类
          - 静态内部类不依赖于外部类的实例，可以独立存在，不能直接访问外部类的非静态成员（需通过外部类实例访问）。
          - 当内部类与外部类的实例无关时使用，避免内部类持有外部类的引用导致的内存泄漏。
  - 深拷贝和浅拷贝
    - 深拷贝和浅拷贝的区别？
      - 浅拷贝是指只复制对象本身和其内部的值类型字段，但不会复制对象内部的引用类型字段。换句话说，浅拷贝只是创建一个新的对象，然后将原对象的字段值复制到新对象中，但如果原对象内部有引用类型的字段，只是将引用复制到新对象中，两个对象指向的是同一个引用对象。
      - 深拷贝是指在复制对象的同时，将对象内部的所有引用类型字段的内容也复制一份，而不是共享引用。换句话说，深拷贝会递归复制对象内部所有引用类型的字段，生成一个全新的对象以及其内部的所有对象。
    -  实现深拷贝的三种方法是什么？
      - 实现 Cloneable 接口并重写 clone() 方法
        - 这种方法要求对象及其所有引用类型字段都实现 Cloneable 接口，并且重写 clone() 方法。在 clone() 方法中，通过递归克隆引用类型字段来实现深拷贝。
        #image("Screenshot_20250915_155729.png")
      - 使用序列化和反序列化
        - 通过将对象序列化为字节流，再从字节流反序列化为对象来实现深拷贝。要求对象及其所有引用类型字段都实现 Serializable 接口。
        - 序列化+反序列化 会让所有对象重新在堆中分配内存，所以原对象和新对象完全独立。
        #image("Screenshot_20250915_155106.png")
      - 手动递归复制
        - 针对特定对象结构，手动递归复制对象及其引用类型字段。适用于对象结构复杂度不高的情况。
  - 泛型
    - 什么是泛型
      - 泛型是 Java 编程语言中的一个重要特性，它允许类、接口和方法在定义时使用一个或多个类型参数，这些类型参数在使用时可以被指定为具体的类型。
      - 泛型的主要目的是在编译时提供更强的类型检查，并且在编译后能够保留类型信息，避免了在运行时出现类型转换异常。
      - 为什么需要泛型？
        - 适用于多种数据类型执行相同的代码
        - 如果没有泛型，要实现不同类型的加法，每种类型都需要重载一个add方法；通过泛型，我们可以复用为一个方法：
        - 泛型中的类型在使用时指定，不需要强制类型转换（类型安全，编译器会检查类型）
        ```java 
                List list = new ArrayList();
        list.add("xxString");
        list.add(100d);
        list.add(new Person());

        ```
        - 我们在使用上述list中，list中的元素都是Object类型（无法约束其中的类型），所以在取出集合元素时需要人为的强制类型转化到具体的目标类型，且很容易出现java.lang.ClassCastException异常。
        - 引入泛型，它将提供类型的约束，提供编译前的检查：
        ```java
        List<String> list = new ArrayList<String>(); 
        ```
  - 对象
    - java创建对象有哪些方式？
      - 使用new关键字：这是最常见、最基础的创建对象方式。通过调用类的构造器来实例化对象。
      - 使用Class类的newInstance()方法：通过 Java 的反射 API，在运行时动态地创建对象。这种方式不需要在编译时知道具体的类。
        - 注意：Class.newInstance() 在 JDK 9 后被标记为过时，因为它只能调用无参公有构造器，且会抛出所有异常。Constructor.newInstance() 更强大、更灵活。
      - 使用Constructor类的newInstance()方法：同样是通过反射机制，可以使用Constructor类的newInstance()方法创建对象。
      - 使用clone()方法：通过实现 Cloneable 接口并重写 Object 类的 clone() 方法，可以基于一个现有对象（原型）创建一个新的副本对象。
        - Object.clone() 默认是浅拷贝，对于引用类型的字段，复制的是引用地址，而不是引用的对象本身。如果需要深拷贝，必须在 clone() 方法中手动对引用对象进行克隆。
      - 使用反序列化 
      - 使用工厂模式：这是一种设计模式，不直接使用 new，而是通过一个方法来返回对象实例。getInstance()、valueOf() 等都是常见的工厂方法。
      #image("Screenshot_20250915_161738.png")
    - Java创建对象除了new还有别的什么方式?
      - 通过反射创建对象：通过 Java 的反射机制可以在运行时动态地创建对象。可以使用 Class 类的 newInstance() 方法或者通过 Constructor 类来创建对象。
      - 通过反序列化创建对象：通过将对象序列化（保存到文件或网络传输）然后再反序列化（从文件或网络传输中读取对象）的方式来创建对象，对象能被序列化和反序列化的前提是类实现Serializable接口。
      - 通过clone创建对象：所有 Java 对象都继承自 Object 类，Object 类中有一个 clone() 方法，可以用来创建对象的副本，要使用 clone 方法，我们必须先实现 Cloneable 接口并实现其定义的 clone 方法。
    - New出的对象什么时候回收？
      - 通过关键字new创建的对象，由Java的垃圾回收器（Garbage Collector）负责回收。垃圾回收器的工作是在程序运行过程中自动进行的，它会周期性地检测不再被引用的对象，并将其回收释放内存。
      - 具体来说，Java对象的回收时机是由垃圾回收器根据一些算法来决定的，主要有以下几种情况：
        - 引用计数法：某个对象的引用计数为0时，表示该对象不再被引用，可以被回收。
        - 可达性分析算法：从根对象（如方法区中的类静态属性、方法中的局部变量等）出发，通过对象之间的引用链进行遍历，如果存在一条引用链到达某个对象，则说明该对象是可达的，反之不可达，不可达的对象将被回收。
        - 终结器（Finalizer）：如果对象重写了finalize()方法，垃圾回收器会在回收该对象之前调用finalize()方法，对象可以在finalize()方法中进行一些清理操作。然而，终结器机制的使用不被推荐，因为它的执行时间是不确定的，可能会导致不可预测的性能问题。
    - 如何获取私有对象？
      - 在 Java 中，私有对象通常指的是类中被声明为 private 的成员变量或方法。由于 private 访问修饰符的限制，这些成员只能在其所在的类内部被访问。
      - 不过，可以通过下面两种方式来间接获取私有对象。
        - 使用公共访问器方法（getter 方法）：如果类的设计者遵循良好的编程规范，通常会为私有成员变量提供公共的访问器方法（即 getter 方法），通过调用这些方法可以安全地获取私有对象。
        - 反射机制。反射机制允许在运行时检查和修改类、方法、字段等信息，通过反射可以绕过 private 访问修饰符的限制来获取私有对象。
  - 反射 
    - 什么是反射
      - 


     