+ java基础面试题
  
  - java特点
    - 平台无关性
      - java的“编写一次，运行无处不在”哲学是其最大的特点之一。Java编译器将源代码编译成字节码（bytecode），该字节码可以在任何安装了Java虚拟机（JVM）的系统上运行。
    - 面向对象
      - Java是一门严格的面向对象编程语言，几乎一切都是对象。面向对象编程（OOP）特性使得代码更易于维护和重用，包括类，对象，继承，多态，抽象，封装
    - 内存管理
      - Java有自己的垃圾回收机制，自动管理内存和回收不再使用的对象。这样，开发者不需要手动管理内存，从而减少内存泄漏和其他内存相关的问题。
  - Java 的优势和劣势是什么？
    - 优势
      - 跨平台
      - 面向对象
      - 生态系统
      - 自动垃圾回收机制
      - 多线程支持
      - 安全模型，沙箱机制
    - 劣势
      - 性能
      - 语法繁琐
      - 内存消耗
      - 开发效率
      - 面向对象过于严格，简单程序反而麻烦
  - Java为什么是跨平台的？
    - Java 能支持跨平台，主要依赖于 JVM 关系比较大。
    - JVM也是一个软件，不同的平台有不同的版本。我们编写的Java源码，编译后会生成一种 .class 文件，称为字节码文件。Java虚拟机就是负责将字节码文件翻译成特定平台下的机器码然后运行。也就是说，只要在不同平台上安装对应的JVM，就可以运行字节码文件，运行我们编写的Java程序。而这个过程中，我们编写的Java程序没有做任何改变，仅仅是通过JVM这一”中间层““，就能在不同平台上运行，真正实现了”一次编译，到处运行“的目的。
    - JVM是一个”桥梁“，是一个”中间件“，是实现跨平台的关键，Java代码首先被编译成字节码文件，再由JVM将字节码文件翻译成机器语言，从而达到运行Java程序的目的。
    - 编译的结果不是生成机器码，而是生成字节码，字节码不能直接运行，必须通过JVM翻译成机器码才能运行。不同平台下编译生成的字节码是一样的，但是由JVM翻译成的机器码却不一样。
    - 所以，运行Java程序必须有JVM的支持，因为编译的结果不是机器码，必须要经过JVM的再次翻译才能执行。即使你将Java程序打包成可执行文件（例如 .exe），仍然需要JVM的支持。
    - 跨平台的是Java程序，不是JVM。JVM是用C/C++开发的，是编译后的机器码，不能跨平台，不同平台下需要安装不同版本的JVM。
  - JVM、JDK、JRE三者关系？
    - JVM是Java虚拟机，是Java程序运行的环境。它负责将Java字节码（由Java编译器生成）解释或编译成机器码，并执行程序。JVM提供了内存管理、垃圾回收、安全性等功能，使得Java程序具备跨平台性。
    - JDK是Java开发工具包，是开发Java程序所需的工具集合。它包含了JVM、编译器（javac）、调试器（jdb）等开发工具，以及一系列的类库（如Java标准库和开发工具库）。JDK提供了开发、编译、调试和运行Java程序所需的全部工具和环境。
    - JRE是Java运行时环境，是Java程序运行所需的最小环境。它包含了JVM和一组Java类库，用于支持Java程序的执行。    JRE不包含开发工具，只提供Java程序运行所需的运行环境。
    #image("Screenshot_20250901_154807.png")
  - 为什么Java解释和编译都有？
    - 首先在Java经过编译之后生成字节码文件，接下来进入JVM中，就有两个步骤编译和解释。 
      - 编译性：
        - Java源代码首先被编译成字节码，JIT 会把编译过的机器码保存起来,以备下次使用。
      - 解释性：
        - JVM中一个方法调用计数器，当累计计数大于一定值的时候，就使用JIT进行编译生成机器码文件。否则就是用解释器进行解释执行，然后字节码也是经过解释器进行解释运行的。
    - 所以Java既是编译型也是解释性语言，默认采用的是解释器和编译器混合的模式。
    #image("Screenshot_20250901_155408.png")
  - jvm是什么
    - JVM是 java 虚拟机，主要工作是解释自己的指令集（即字节码）并映射到本地的CPU指令集和OS的系统调用。
    - JVM屏蔽了与操作系统平台相关的信息，使得Java程序只需要生成在Java虚拟机上运行的目标代码（字节码），就可在多种平台上不加修改的运行，这也是Java能够“一次编译，到处运行的”原因。
  - 编译型语言和解释型语言的区别？
    - 编译型语言：在程序执行之前，整个源代码会被编译成机器码或者字节码，生成可执行文件。执行时直接运行编译后的代码，速度快，但跨平台性较差。
    - 解释型语言：在程序执行时，逐行解释执行源代码，不生成独立的可执行文件。通常由解释器动态解释并执行代码，跨平台性好，但执行速度相对较慢。
    - 典型的编译型语言如C、C++，典型的解释型语言如Python、JavaScript。
    #image("Screenshot_20250901_161224.png")
    #image("Screenshot_20250901_161233.png")
    - 所以解释性语言是把代码解释成指令直接给cpu或者操作系统执行，只要有对应的解释器就可以在多个平台运行，而编译性语言是编译成机器码执行，而机器码与平台相关，所以跨平台性不好
  -  Python和Java区别是什么？
    - Java是一种已编译的编程语言，Java编译器将源代码编译为字节码，而字节码则由Java虚拟机执行
    - python是一种解释语言，翻译时会在执行程序的同时进行翻译。
- 数据类型
  - 八种基本的数据类型
    - Java支持数据类型分为两类： 基本数据类型和引用数据类型。
      - 基本数据类型共有8种，可以分为三类：
        - 数值型：整数类型（byte、short、int、long）和浮点类型（float、double）
        - 字符型：char
        - 布尔型：boolean
        #image("Screenshot_20250901_162217.png")
    - Float和Double的最小值和最大值都是以科学记数法的形式输出的，结尾的“E+数字”表示E之前的数字要乘以10的多少倍。比如3.14E3就是3.14×1000=3140
    - Java八种基本数据类型的字节数：1字节(byte、boolean)、 2字节(short、char)、4字节(int、float)、8字节(long、double)
    - 浮点数的默认类型为double（如果需要声明一个常量为float型，则必须要在末尾加上f或F）
    - 整数的默认类型为int（声明Long型在末尾加上l或者L）
    - 八种基本数据类型的包装类：除了char的是Character、int类型的是Integer，其他都是首字母大写
    - char类型是无符号的，不能为负，所以是0开始的
  - int和long是多少位，多少字节的？
    - int类型是 32 位（bit），占 4 个字节（byte），int 是有符号整数类型，其取值范围是从 -2^31 到 2^31-1 。
    - long类型是 64 位，占 8 个字节，long类型也是有符号整数类型，它的取值范围是从 -2^63 到 2^63 -1 ，在处理较大的整数数值时，果int类型的取值范围不够，就需要使用long类型。
  -  long和int可以互转吗 ？
    - 可以的，Java中的long和int可以相互转换。由于long类型的范围比int类型大，因此将int转换为long是安全的，而将long转换为int可能会导致数据丢失或溢出。
    - 将int转换为long可以通过直接赋值或强制类型转换来实现。
    - 将long转换为int需要使用强制类型转换，但需要注意潜在的数据丢失或溢出问题。
    - 在将long转换为int时，如果longValue的值超出了int类型的范围，转换结果将是截断后的低位部分。因此，在进行转换之前，建议先检查longValue的值是否在int类型的范围内，以避免数据丢失或溢出的问题。
  - 数据类型转换方式你知道哪些？
    - 自动类型转换（隐式转换）：当目标类型的范围大于源类型时，Java会自动将源类型转换为目标类型，不需要显式的类型转换。例如，将int转换为long、将float转换为double等。
    - 强制类型转换（显式转换）：当目标类型的范围小于源类型时，需要使用强制类型转换将源类型转换为目标类型。这可能导致数据丢失或溢出。例如，将long转换为int、将double转换为int等。语法为：目标类型 变量名 = (目标类型) 源类型。
    - 字符串转换：Java提供了将字符串表示的数据转换为其他类型数据的方法。例如，将字符串转换为整型int，可以使用Integer.parseInt()方法；将字符串转换为浮点型double，可以使用Double.parseDouble()方法等。
    - 数值之间的转换：Java提供了一些数值类型之间的转换方法，如将整型转换为字符型、将字符型转换为整型等。这些转换方式可以通过类型的包装类来实现，例如Character类、Integer类等提供了相应的转换方法。
  - 类型互转会出现什么问题
    - 当把小范围数据类型赋值给大范围数据类型时，Java 会自动进行类型转换，这种转换一般是安全的。
    - 基本数据类型转换的问题
      - 大范围数据类型赋值给小范围数据类型时，会发生数据数据溢出或者精度损失的问题。
        - 数据溢出：如果大范围数据类型赋值给小范围数据类型时，当目标类型无法容纳原数据时，就会发生数据溢出。比如下面，byte 类型的取值范围是 - 128 到 127。300 的二进制表示为00000001 00101100，强制转换为 byte 类型时，会丢弃高位字节，只保留低位的 8 位00101100，其十进制值为 44。
        ```java 
                  int largeNum = 300;
        byte b = (byte) largeNum; // b的值为44
        ```
      - 精度损失：在进行浮点数类型的转换时，可能会发生精度损失。由于浮点数的表示方式不同，将一个单精度浮点数(float)转换为双精度浮点数(double)时，精度可能会损失，如果 double 转换为 int 也会发生精度损失的问题，如下：
      ```java 
      double d = 3.14;
      int i = (int) d; // i的值为3，小数部分0.14被舍弃
      ```
    - 对象引用转换的问题
      - 向上转型是自动进行的，而且是安全的
      - 但是向下转型需要手动进行，并且存在风险。如果父类对象实际上并不是目标子类的实例，在转型时就会抛出异常：
      - 原因是Java 的对象在运行时会记录其真实类型，当进行向下转型时，Java 会检查对象的实际类型是否与目标类型兼容。如果不兼容，就会抛出ClassCastException。
      - 解决方式是需要使用 instanceof 检查：
          ```java 
          if (animal instanceof Dog) {
      Dog dog = (Dog) animal; // 只有确认animal是Dog的实例时才进行转型
        }
          ```
    - 为什么用bigDecimal 不用double ？
      - double会出现精度丢失的问题，double执行的是二进制浮点运算，二进制有些情况下不能准确的表示一个小数，就像十进制不能准确的表示1/3(1/3=0.3333...)，也就是说二进制表示小数的时候只能够表示能够用1/(2^n)的和的任意组合，但是0.1不能够精确表示，因为它不能够表示成为1/(2^n)的和的形式。
      - 可以看到在Java中进行浮点数运算的时候，会出现丢失精度的问题。那么我们如果在进行商品价格计算的时候，就会出现问题。很有可能造成我们手中有0.06元，却无法购买一个0.05元和一个0.01元的商品。因为如上所示，他们两个的总和为0.060000000000000005。这无疑是一个很严重的问题，尤其是当电商网站的并发量上去的时候，出现的问题将是巨大的。可能会导致无法下单，或者对账出现问题。
      - 而 Decimal 是精确计算 , 所以一般牵扯到金钱的计算 , 都使用 Decimal。
      - 要注意的是，在创建BigDecimal对象时，应该使用字符串作为参数，而不是直接使用浮点数值，以避免浮点数精度丢失。
      ```java
      BigDecimal num1 = new BigDecimal("0.1"); 
      ```
  - 装箱和拆箱是什么？
    - 装箱（Boxing）和拆箱（Unboxing）是将基本数据类型和对应的包装类之间进行转换的过程。
    - 自动装箱主要发生在两种情况，一种是赋值时，另一种是在方法调用的时候。
      - 赋值时
        - 这是最常见的一种情况，在Java 1.5以前我们需要手动地进行转换才行，而现在所有的转换都是由编译器来完成。
                  ```java 
                  ```//before autoboxing
        Integer iObject = Integer.valueOf(3);
        Int iPrimitive = iObject.intValue()

        //after java5
        Integer iObject = 3; //autobxing - primitive to wrapper conversion
        int iPrimitive = iObject; //unboxing - object to primitive conversion
      - 方法调用时
        - 当我们在方法调用时，我们可以传入原始数据值或者对象，同样编译器会帮我们进行转换。
        ```java 
                  public static Integer show(Integer iParam){
          System.out.println("autoboxing example - method invocation i: " + iParam);
          return iParam;
        }

        //autoboxing and unboxing in method invocation
        show(3); //autoboxing
        int result = show(3); //unboxing because return type of method is Integer

        ```
        - show方法接受Integer对象作为参数，当调用show(3)时，会将int值转换成对应的Integer对象，这就是所谓的自动装箱，show方法返回Integer对象，而int result = show(3);中result为int类型，所以这时候发生自动拆箱操作，将show方法的返回的Integer对象转换成int值。
      - 自动装箱的弊端
        - 自动装箱有一个问题，那就是在一个循环中进行自动装箱操作的情况，如下面的例子就会创建多余的对象，影响程序的性能。
        ```java
        Integer sum = 0; for(int i=1000; i<5000; i++){   sum+=i; }  
        ```
        - 上面的代码sum+=i可以看成sum = sum + i，但是+这个操作符不适用于Integer对象，首先sum进行自动拆箱操作，进行数值相加操作，最后发生自动装箱操作转换成Integer对象
        - 由于我们这里声明的sum为Integer类型，在上面的循环中会创建将近4000个无用的Integer对象，在这样庞大的循环中，会降低程序的性能并且加重了垃圾回收的工作量。因此在我们编程时，需要注意到这一点，正确地声明变量类型，避免因为自动装箱引起的性能问题。
  - Java为什么要有Integer？
    - Integer对应是int类型的包装类，就是把int类型包装成Object对象，对象封装有很多好处，可以把属性也就是数据跟处理这些数据的方法结合在一起，比如Integer就有parseInt()等方法来专门处理int型相关的数据。
    - 另一个非常重要的原因就是在Java中绝大部分方法或类都是用来处理类类型对象的，如ArrayList集合类就只能以类作为他的存储对象，而这时如果想把一个int型的数据存入list是不可能的，必须把它包装成类，也就是Integer才能被List所接受。所以Integer的存在是很必要的。
    - 泛型中的应用
      - 在Java中，泛型只能使用引用类型，而不能使用基本类型。因此，如果要在泛型中使用int类型，必须使用Integer包装类。例如，假设我们有一个列表，我们想要将其元素排序，并将排序结果存储在一个新的列表中。如果我们使用基本数据类型int，无法直接使用Collections.sort()方法。但是，如果我们使用Integer包装类，我们就可以轻松地使用Collections.sort()方法。
      ```java 
              List<Integer> list = new ArrayList<>();
      list.add(3);
      list.add(1);
      list.add(2);
      Collections.sort(list);
      System.out.println(list);

      ```
    - 转换中的应用
      - 在Java中，基本类型和引用类型不能直接进行转换，必须使用包装类来实现。例如，将一个int类型的值转换为String类型，必须首先将其转换为Integer类型，然后再转换为String类型。
      ```java
              int i = 10;
      Integer integer = new Integer(i);
      String str = integer.toString();
      System.out.println(str);

      ```
    - 集合中的应用
      - Java集合中只能存储对象，而不能存储基本数据类型。因此，如果要将int类型的数据存储在集合中，必须使用Integer包装类。例如，假设我们有一个列表，我们想要计算列表中所有元素的和。如果我们使用基本数据类型int，我们需要使用一个循环来遍历列表，并将每个元素相加。但是，如果我们使用Integer包装类，我们可以直接使用stream()方法来计算所有元素的和。
      ```java
              List<Integer> list = new ArrayList<>();
      list.add(3);
      list.add(1);
      list.add(2);
      int sum = list.stream().mapToInt(Integer::intValue).sum();
      System.out.println(sum);

      ```
  - Integer相比int有什么优点？
    - 基本类型和引用类型：首先，int是一种基本数据类型，而Integer是一种引用类型。基本数据类型是Java中最基本的数据类型，它们是预定义的，不需要实例化就可以使用。而引用类型则需要通过实例化对象来使用。这意味着，使用int来存储一个整数时，不需要任何额外的内存分配，而使用Integer时，必须为对象分配内存。在性能方面，基本数据类型的操作通常比相应的引用类型快。
    - 自动装箱和拆箱：其次，Integer作为int的包装类，它可以实现自动装箱和拆箱。自动装箱是指将基本类型转化为相应的包装类类型，而自动拆箱则是将包装类类型转化为相应的基本类型。这使得Java程序员更加方便地进行数据类型转换。例如，当我们需要将int类型的值赋给Integer变量时，Java可以自动地将int类型转换为Integer类型。同样地，当我们需要将Integer类型的值赋给int变量时，Java可以自动地将Integer类型转换为int类型。
    - 空指针异常：另外，int变量可以直接赋值为0，而Integer变量必须通过实例化对象来赋值。如果对一个未经初始化的Integer变量进行操作，就会出现空指针异常。这是因为它被赋予了null值，而null值是无法进行自动拆箱的。
  - 那为什么还要保留int类型？
    - 包装类是引用类型，对象的引用和对象本身是分开存储的，而对于基本类型数据，变量对应的内存块直接存储数据本身。
    - 因此，基本类型数据在读写效率方面，要比包装类高效。除此之外，在64位JVM上，在开启引用压缩的情况下，一个Integer对象占用16个字节的内存空间，而一个int类型数据只占用4字节的内存空间，前者对空间的占用是后者的4倍。
    - 也就是说，不管是读写效率，还是存储效率，基本类型都比包装类高效。
  - 说一下 integer的缓存
    - Java的Integer类内部实现了一个静态缓存池，用于存储特定范围内的整数值对应的Integer对象。
    - 默认情况下，这个范围是-128至127。当通过Integer.valueOf(int)方法创建一个在这个范围内的整数对象时，并不会每次都生成新的对象实例，而是复用缓存中的现有对象，会直接从内存中取出，不需要新建一个对象
    #image("Screenshot_20250908_144457.png")
    #image("Screenshot_20250908_144514.png")

  - 怎么理解面向对象？简单说说封装继承多态
    - 面向对象是一种编程范式，它将现实世界中的事物抽象为对象，对象具有属性（称为字段或属性）和行为（称为方法）。面向对象编程的设计思想是以对象为中心，通过对象之间的交互来完成程序的功能，具有灵活性和可扩展性，通过封装和继承可以更好地应对需求变化。
    - Java面向对象的三大特性包括：封装、继承、多态：
    - 封装：封装是指将对象的属性（数据）和行为（方法）结合在一起，对外隐藏对象的内部细节，仅通过对象提供的接口与外界交互。封装的目的是增强安全性和简化编程，使得对象更加独立。
    - 继承：继承是一种可以使得子类自动共享父类数据结构和方法的机制。它是代码复用的重要手段，通过继承可以建立类与类之间的层次关系，使得结构更加清晰。
    - 多态：多态是指允许不同类的对象对同一消息作出响应。即同一个接口，使用不同的实例而执行不同操作。多态性可以分为编译时多态（重载）和运行时多态（重写）。它使得程序具有良好的灵活性和扩展性。
  - 多态体现在哪几个方面？
    - 多态在面向对象编程中可以体现在以下几个方面：
      - 方法重载：
        - 方法重载是指同一类中可以有多个同名方法，它们具有不同的参数列表（参数类型、数量或顺序不同）。虽然方法名相同，但根据传入的参数不同，编译器会在编译时确定调用哪个方法。
        - 示例：对于一个 add 方法，可以定义为 add(int a, int b) 和 add(double a, double b)。
      - 方法重写：
        - 方法重写是指子类能够提供对父类中同名方法的具体实现。在运行时，JVM会根据对象的实际类型确定调用哪个版本的方法。这是实现多态的主要方式。
        - 示例：在一个动物类中，定义一个 sound 方法，子类 Dog 可以重写该方法以实现 bark，而 Cat 可以实现 meow。
      - 接口与实现：
        - 多态也体现在接口的使用上，多个类可以实现同一个接口，并且用接口类型的引用来调用这些类的方法。这使得程序在面对不同具体实现时保持一贯的调用方式。
        - 示例：多个类（如 Dog, Cat）都实现了一个 Animal 接口，当用 Animal 类型的引用来调用 makeSound 方法时，会触发对应的实现。
      - 向上转型和向下转型：
        - 在Java中，可以使用父类类型的引用指向子类对象，这是向上转型。通过这种方式，可以在运行时期采用不同的子类实现。
        - 向下转型是将父类引用转回其子类类型，但在执行前需要确认引用实际指向的对象类型以避免 ClassCastException。
  - 多态解决了什么问题？
    - 多态是指子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。多态这种特性也需要编程语言提供特殊的语法机制来实现，比如继承、接口类。
    - 多态可以提高代码的扩展性和复用性，是很多设计模式、设计原则、编程技巧的代码实现基础。比如策略模式、基于接口而非实现编程、依赖倒置原则、里式替换原则、利用多态去掉冗长的 if-else 语句等等
  - 面向对象的设计原则你知道有哪些吗
    - 单一职责原则（SRP）：一个类应该只有一个引起它变化的原因，即一个类应该只负责一项职责。例子：考虑一个员工类，它应该只负责管理员工信息，而不应负责其他无关工作。
    - 开放封闭原则（OCP）：软件实体应该对扩展开放，对修改封闭。例子：通过制定接口来实现这一原则，比如定义一个图形类，然后让不同类型的图形继承这个类，而不需要修改图形类本身。
    - 里氏替换原则（LSP）：子类对象应该能够替换掉所有父类对象。例子：一个正方形是一个矩形，但如果修改一个矩形的高度和宽度时，正方形的行为应该如何改变就是一个违反里氏替换原则的例子。
    - 接口隔离原则（ISP）：客户端不应该依赖那些它不需要的接口，即接口应该小而专。例子：通过接口抽象层来实现底层和高层模块之间的解耦，比如使用依赖注入。
    - 依赖倒置原则（DIP）：高层模块不应该依赖低层模块，二者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。例子：如果一个公司类包含部门类，应该考虑使用合成/聚合关系，而不是将公司类继承自部门类。
    - 最少知识原则 (Law of Demeter)：一个对象应当对其他对象有最少的了解，只与其直接的朋友交互。
  - 重载与重写有什么区别？
    - 重载（Overloading）指的是在同一个类中，可以有多个同名方法，它们具有不同的参数列表（参数类型、参数个数或参数顺序不同），编译器根据调用时的参数类型来决定调用哪个方法。（返回类型不可以作为重载的区分条件）
    - 重写（Overriding）指的是子类可以重新定义父类中的方法，方法名、参数列表和返回类型必须与父类中的方法一致，通过override注解来明确表示这是对父类方法的重写。
    - 重载是指在同一个类中定义多个同名方法，而重写是指子类重新定义父类中的方法。
  - 抽象类和普通类区别？
    - 实例化：普通类可以直接实例化对象，而抽象类不能被实例化，只能被继承。
    - 方法实现：普通类中的方法可以有具体的实现，而抽象类中的方法可以有实现也可以没有实现。
    - 继承：一个类可以继承一个普通类，而且可以继承多个接口；而一个类只能继承一个抽象类，但可以同时实现多个接口。
    - 实现限制：普通类可以被其他类继承和使用，而抽象类一般用于作为基类，被其他类继承和扩展使用。
  - Java抽象类和接口的区别是什么？
    - 两者的特点：
      - 抽象类用于描述类的共同特性和行为，可以有成员变量、构造方法和具体方法。适用于有明显继承关系的场景。
      - 接口用于定义行为规范，可以多实现，只能有常量和抽象方法（Java 8 以后可以有默认方法和静态方法）。适用于定义类的能力或功能。
    - 两者的区别：
      - 实现方式：实现接口的关键字为implements，继承抽象类的关键字为extends。一个类可以实现多个接口，但一个类只能继承一个抽象类。所以，使用接口可以间接地实现多重继承。
      - 方法方式：接口只有定义，不能有方法的实现，java 1.8中可以定义default方法体，而抽象类可以有定义与实现，方法可在抽象类中实现。
      - 访问修饰符：接口成员变量默认为public static final，必须赋初值，不能被修改；其所有的成员方法都是public、abstract的。抽象类中成员变量默认default，可在子类中被重新定义，也可被重新赋值；抽象方法被abstract修饰，不能被private、static、synchronized和native等修饰，必须以分号结尾，不带花括号。
      - 变量：抽象类可以包含实例变量和静态变量，而接口只能包含常量（即静态常量）。
  -  抽象类能加final修饰吗？
    - 不能，Java中的抽象类是用来被继承的，而final修饰符用于禁止类被继承或方法被重写，因此，抽象类和final修饰符是互斥的，不能同时使用。
  - 接口里面可以定义哪些方法？
    - 抽象方法
      - 抽象方法是接口的核心部分，所有实现接口的类都必须实现这些方法。抽象方法默认是 public 和 abstract，这些修饰符可以省略。
    - 默认方法
      - 默认方法是在 Java 8 中引入的，允许接口提供具体实现。实现类可以选择重写默认方法。
    - 静态方法
      - 静态方法也是在 Java 8 中引入的，它们属于接口本身，可以通过接口名直接调用，而不需要实现类的对象。
    - 私有方法
      - 私有方法是在 Java 9 中引入的，用于在接口中为默认方法或其他私有方法提供辅助功能。这些方法不能被实现类访问，只能在接口内部使用。
  - 抽象类可以被实例化吗？
    - 在Java中，抽象类本身不能被实例化。
    - 这意味着不能使用new关键字直接创建一个抽象类的对象。抽象类的存在主要是为了被继承，它通常包含一个或多个抽象方法（由abstract关键字修饰且无方法体的方法），这些方法需要在子类中被实现。
    - 抽象类可以有构造器，这些构造器在子类实例化时会被调用，以便进行必要的初始化工作。然而，这个过程并不是直接实例化抽象类，而是创建了子类的实例，间接地使用了抽象类的构造器。
    - 在这个例子中，ConcreteClass继承了AbstractClass并实现了抽象方法abstractMethod()。当我们创建ConcreteClass的实例时，AbstractClass的构造器被调用，但这并不意味着AbstractClass被实例化；实际上，我们创建的是ConcreteClass的一个对象。
  - 接口可以包含构造函数吗？
    - 在接口中，不可以有构造方法,在接口里写入构造方法时，编译器提示：Interfaces cannot have constructors，因为接口不会有自己的实例的，所以不需要有构造函数。
    - 为什么呢？构造函数就是初始化class的属性或者方法，在new的一瞬间自动调用，那么问题来了Java的接口，都不能new 那么要构造函数干嘛呢？根本就没法调用
  - 解释Java中的静态变量和静态方法
    - 在Java中，静态变量和静态方法是与类本身关联的，而不是与类的实例（对象）关联。它们在内存中只存在一份，可以被类的所有实例共享。
    - 静态变量
      - 静态变量（也称为类变量）是在类中使用static关键字声明的变量。它们属于类而不是任何具体的对象。主要的特点：
        - 共享性：所有该类的实例共享同一个静态变量。如果一个实例修改了静态变量的值，其他实例也会看到这个更改。
        - 初始化：静态变量在类被加载时初始化，只会对其进行一次分配内存。
        - 访问方式：静态变量可以直接通过类名访问，也可以通过实例访问，但推荐使用类名。
    - 静态方法
      - 静态方法是在类中使用static关键字声明的方法。类似于静态变量，静态方法也属于类，而不是任何具体的对象。主要的特点：
        - 无实例依赖：静态方法可以在没有创建类实例的情况下调用。对于静态方法来说，不能直接访问非静态的成员变量或方法，因为静态方法没有上下文的实例。
        - 访问静态成员：静态方法可以直接调用其他静态变量和静态方法，但不能直接访问非静态成员。
        - 多态性：静态方法不支持重写（Override），但可以被隐藏（Hide）。
    - 使用场景
      - 静态变量：常用于需要在所有对象间共享的数据，如计数器、常量等。
      - 静态方法：常用于助手方法（utility methods）、获取类级别的信息或者是没有依赖于实例的数据处理。
  - 非静态内部类和静态内部类的区别？
    - 非静态内部类依赖于外部类的实例，而静态内部类不依赖于外部类的实例。
    - 非静态内部类可以访问外部类的实例变量和方法，而静态内部类只能访问外部类的静态成员。
    - 非静态内部类不能定义静态成员，而静态内部类可以定义静态成员。
    - 非静态内部类在外部类实例化后才能实例化，而静态内部类可以独立实例化。
    - 非静态内部类可以访问外部类的私有成员，而静态内部类不能直接访问外部类的私有成员，需要通过实例化外部类来访问。
  - 非静态内部类可以直接访问外部方法，编译器是怎么做到的？
    - 非静态内部类可以直接访问外部方法是因为编译器在生成字节码时会为非静态内部类维护一个指向外部类实例的引用。
    - 这个引用使得非静态内部类能够访问外部类的实例变量和方法。编译器会在生成非静态内部类的构造方法时，将外部类实例作为参数传入，并在内部类的实例化过程中建立外部类实例与内部类实例之间的联系，从而实现直接访问外部方法的功能。

  - Java 中 final 作用是什么？
      - final关键字主要有以下三个方面的作用：用于修饰类、方法和变量。
        - 修饰类：当final修饰一个类时，表示这个类不能被继承，是类继承体系中的最终形态。例如，Java 中的String类就是用final修饰的，这保证了String类的不可变性和安全性，防止其他类通过继承来改变String类的行为和特性。
        - 修饰方法：用final修饰的方法不能在子类中被重写。比如，java.lang.Object类中的getClass方法就是final的，因为这个方法的行为是由 Java 虚拟机底层实现来保证的，不应该被子类修改。
        - 修饰变量：当final修饰基本数据类型的变量时，该变量一旦被赋值就不能再改变。例如，final int num = 10;，这里的num就是一个常量，不能再对其进行重新赋值操作，否则会导致编译错误。对于引用数据类型，final修饰意味着这个引用变量不能再指向其他对象，但对象本身的内容是可以改变的。例如，final StringBuilder sb = new StringBuilder("Hello");，不能让sb再指向其他StringBuilder对象，但可以通过sb.append(" World");来修改字符串的内容。
      - 当final修饰对象的时候，若对象的变量不用final修饰，则可以修改变量的值，final只是保证引用不变
      - final修饰类不能被继承，final修饰方法不能被重写
      - 声明一个类不能又是abstract又是final，抽象类要被继承，而final不能被继承
    - Java 中 static的作用是什么？
      - static 关键字主要用于修饰类的成员（变量、方法、代码块）和内部类，其核心作用是将成员与类本身关联，而非与类的实例（对象）关联。具体作用如下：
        - 修饰变量
          - 被 static 修饰的变量属于类本身，而非类的某个实例。所有对象共享同一份静态变量，内存中只存在一份副本。可以通过 类名.变量名 直接访问，无需创建对象（也可通过对象访问，但不推荐）。
          - 通常用于存储所有对象共享的数据，如常量、计数器等。
        - 修饰方法
          - 静态方法属于类，不属于任何实例，因此不能直接访问类中的非静态成员（变量 / 方法）（因为非静态成员依赖于对象存在），但可以访问静态成员。通过 类名.方法名 直接调用，无需创建对象。 
          - 通常用于工具类方法（如 Math.random()）、工厂方法等，不需要依赖对象状态即可完成操作。
        - 修饰代码块
          - 静态代码块在类加载时执行，且只执行一次（优于对象构造方法），用于初始化静态变量或执行类级别的预处理操作。
          - 多个静态代码块按定义顺序执行，且先于非静态代码块和构造方法。
        - 修饰内部类
          - 静态内部类不依赖于外部类的实例，可以独立存在，不能直接访问外部类的非静态成员（需通过外部类实例访问）。
          - 当内部类与外部类的实例无关时使用，避免内部类持有外部类的引用导致的内存泄漏。
  
  - 深拷贝和浅拷贝的区别？
    - 浅拷贝是指只复制对象本身和其内部的值类型字段，但不会复制对象内部的引用类型字段。换句话说，浅拷贝只是创建一个新的对象，然后将原对象的字段值复制到新对象中，但如果原对象内部有引用类型的字段，只是将引用复制到新对象中，两个对象指向的是同一个引用对象。
    - 深拷贝是指在复制对象的同时，将对象内部的所有引用类型字段的内容也复制一份，而不是共享引用。换句话说，深拷贝会递归复制对象内部所有引用类型的字段，生成一个全新的对象以及其内部的所有对象。
  -  实现深拷贝的三种方法是什么？
    - 实现 Cloneable 接口并重写 clone() 方法
      - 这种方法要求对象及其所有引用类型字段都实现 Cloneable 接口，并且重写 clone() 方法。在 clone() 方法中，通过递归克隆引用类型字段来实现深拷贝。
      #image("Screenshot_20250915_155729.png")
    - 使用序列化和反序列化
      - 通过将对象序列化为字节流，再从字节流反序列化为对象来实现深拷贝。要求对象及其所有引用类型字段都实现 Serializable 接口。
      - 序列化+反序列化 会让所有对象重新在堆中分配内存，所以原对象和新对象完全独立。
      #image("Screenshot_20250915_155106.png")
    - 手动递归复制
      - 针对特定对象结构，手动递归复制对象及其引用类型字段。适用于对象结构复杂度不高的情况。

  - 什么是泛型
    - 泛型是 Java 编程语言中的一个重要特性，它允许类、接口和方法在定义时使用一个或多个类型参数，这些类型参数在使用时可以被指定为具体的类型。
    - 泛型的主要目的是在编译时提供更强的类型检查，并且在编译后能够保留类型信息，避免了在运行时出现类型转换异常。
    - 为什么需要泛型？
      - 适用于多种数据类型执行相同的代码
      - 如果没有泛型，要实现不同类型的加法，每种类型都需要重载一个add方法；通过泛型，我们可以复用为一个方法：
      - 泛型中的类型在使用时指定，不需要强制类型转换（类型安全，编译器会检查类型）
      ```java 
              List list = new ArrayList();
      list.add("xxString");
      list.add(100d);
      list.add(new Person());

      ```
      - 我们在使用上述list中，list中的元素都是Object类型（无法约束其中的类型），所以在取出集合元素时需要人为的强制类型转化到具体的目标类型，且很容易出现java.lang.ClassCastException异常。
      - 引入泛型，它将提供类型的约束，提供编译前的检查：
      ```java
      List<String> list = new ArrayList<String>(); 
      ```

  - java创建对象有哪些方式？
    - 使用new关键字：这是最常见、最基础的创建对象方式。通过调用类的构造器来实例化对象。
    - 使用Class类的newInstance()方法：通过 Java 的反射 API，在运行时动态地创建对象。这种方式不需要在编译时知道具体的类。
      - 注意：Class.newInstance() 在 JDK 9 后被标记为过时，因为它只能调用无参公有构造器，且会抛出所有异常。Constructor.newInstance() 更强大、更灵活。
    - 使用Constructor类的newInstance()方法：同样是通过反射机制，可以使用Constructor类的newInstance()方法创建对象。
    - 使用clone()方法：通过实现 Cloneable 接口并重写 Object 类的 clone() 方法，可以基于一个现有对象（原型）创建一个新的副本对象。
      - Object.clone() 默认是浅拷贝，对于引用类型的字段，复制的是引用地址，而不是引用的对象本身。如果需要深拷贝，必须在 clone() 方法中手动对引用对象进行克隆。
    - 使用反序列化 
    - 使用工厂模式：这是一种设计模式，不直接使用 new，而是通过一个方法来返回对象实例。getInstance()、valueOf() 等都是常见的工厂方法。
    #image("Screenshot_20250915_161738.png")
  - Java创建对象除了new还有别的什么方式?
    - 通过反射创建对象：通过 Java 的反射机制可以在运行时动态地创建对象。可以使用 Class 类的 newInstance() 方法或者通过 Constructor 类来创建对象。
    - 通过反序列化创建对象：通过将对象序列化（保存到文件或网络传输）然后再反序列化（从文件或网络传输中读取对象）的方式来创建对象，对象能被序列化和反序列化的前提是类实现Serializable接口。
    - 通过clone创建对象：所有 Java 对象都继承自 Object 类，Object 类中有一个 clone() 方法，可以用来创建对象的副本，要使用 clone 方法，我们必须先实现 Cloneable 接口并实现其定义的 clone 方法。
  - New出的对象什么时候回收？
    - 通过关键字new创建的对象，由Java的垃圾回收器（Garbage Collector）负责回收。垃圾回收器的工作是在程序运行过程中自动进行的，它会周期性地检测不再被引用的对象，并将其回收释放内存。
    - 具体来说，Java对象的回收时机是由垃圾回收器根据一些算法来决定的，主要有以下几种情况：
      - 引用计数法：某个对象的引用计数为0时，表示该对象不再被引用，可以被回收。
      - 可达性分析算法：从根对象（如方法区中的类静态属性、方法中的局部变量等）出发，通过对象之间的引用链进行遍历，如果存在一条引用链到达某个对象，则说明该对象是可达的，反之不可达，不可达的对象将被回收。
      - 终结器（Finalizer）：如果对象重写了finalize()方法，垃圾回收器会在回收该对象之前调用finalize()方法，对象可以在finalize()方法中进行一些清理操作。然而，终结器机制的使用不被推荐，因为它的执行时间是不确定的，可能会导致不可预测的性能问题。
  - 如何获取私有对象？
    - 在 Java 中，私有对象通常指的是类中被声明为 private 的成员变量或方法。由于 private 访问修饰符的限制，这些成员只能在其所在的类内部被访问。
    - 不过，可以通过下面两种方式来间接获取私有对象。
      - 使用公共访问器方法（getter 方法）：如果类的设计者遵循良好的编程规范，通常会为私有成员变量提供公共的访问器方法（即 getter 方法），通过调用这些方法可以安全地获取私有对象。
      - 反射机制。反射机制允许在运行时检查和修改类、方法、字段等信息，通过反射可以绕过 private 访问修饰符的限制来获取私有对象。

  - 什么是反射
    - Java 反射机制是在运行状态中，对于任意一个类，都能够知道这个类中的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。
    - 反射具有以下特性
      - 运行时类信息访问：反射机制允许程序在运行时获取类的完整结构信息，包括类名、包名、父类、实现的接口、构造函数、方法和字段等。
      - 动态对象创建：可以使用反射API动态地创建对象实例，即使在编译时不知道具体的类名。这是通过Class类的newInstance()方法或Constructor对象的newInstance()方法实现的。
      - 动态方法调用：可以在运行时动态地调用对象的方法，包括私有方法。这通过Method类的invoke()方法实现，允许你传入对象实例和参数值来执行方法。
      - 访问和修改字段值：反射还允许程序在运行时访问和修改对象的字段值，即使是私有的。这是通过Field类的get()和set()方法完成的。
  - 反射在你平时写代码或者框架中的应用场景有哪些?
    - 加载数据库驱动
      - 我们的项目底层数据库有时是用mysql，有时用oracle，需要动态地根据实际情况加载驱动类，这个时候反射就有用了，假设 com.mikechen.java.myqlConnection，com.mikechen.java.oracleConnection这两个类我们要用。
      - 这时候我们在使用 JDBC 连接数据库时使用 Class.forName()通过反射加载数据库的驱动程序，如果是mysql则传入mysql的驱动类，而如果是oracle则传入的参数就变成另一个了。
    - 配置文件加载
      - Spring 框架的 IOC（动态加载管理 Bean），Spring通过配置文件配置各种各样的bean，你需要用到哪些bean就配哪些，spring容器就会根据你的需求去动态加载，你的程序就能健壮地运行。
      - Spring通过XML配置模式装载Bean的过程：
        - 将程序中所有XML或properties配置文件加载入内存
        - Java类里面解析xml或者properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息
        - 使用反射机制，根据这个字符串获得某个类的Class实例
        - 动态配置实例的属性

  - 能讲一讲Java注解的原理吗？
    - 注解本质是一个继承了Annotation的特殊接口，其具体实现类是Java运行时生成的动态代理类。
    - 我们通过反射获取注解时，返回的是Java运行时生成的动态代理对象。通过代理对象调用自定义注解的方法，会最终调用AnnotationInvocationHandler的invoke方法。该方法会从memberValues这个Map中索引出对应的值。而memberValues的来源是Java常量池。
  - 对注解解析的底层实现了解吗？
    - 注解本质上是一种特殊的接口，它继承自 java.lang.annotation.Annotation 接口，所以注解也叫声明式接口
    - 编译后，Java 编译器会将其转换为一个继承自 Annotation 的接口，并生成相应的字节码文件。
    - 根据注解的作用范围，Java 注解可以分为以下几种类型：
      - 源码级别注解 ：仅存在于源码中，编译后不会保留
      - 类文件级别注解 ：保留在 .class 文件中，但运行时不可见
      - 运行时注解 ：保留在 .class 文件中，并且可以通过反射在运行时访问
    - 当注解被标记为 RUNTIME 时，Java 编译器会在生成的 .class 文件中保存注解信息。这些信息存储在字节码的属性表（Attribute Table）中，具体包括以下内容：
      - RuntimeVisibleAnnotations ：存储运行时可见的注解信息。
      - RuntimeInvisibleAnnotations ：存储运行时不可见的注解信息。
      - RuntimeVisibleParameterAnnotations 和 RuntimeInvisibleParameterAnnotations ：存储方法参数上的注解信息。
    - 通过工具（如 javap -v）可以查看 .class 文件中的注解信息。
    - 注解的解析主要依赖于 Java 的反射机制。以下是解析注解的基本流程：
      - 获取注册信息：通过反射 API 可以获取类、方法、字段等元素上的注解。
      - 底层原理：反射机制的核心类是 java.lang.reflect.AnnotatedElement，它是所有可以被注解修饰的元素（如 Class、Method、Field 等）的父接口。该接口提供了以下方法：
        - getAnnotation(Class\<T> annotationClass)：获取指定类型的注解。
        - getAnnotations()：获取所有注解。
        - isAnnotationPresent(Class<? extends Annotation> annotationClass)：判断是否包含指定注解。
      - 这些方法的底层实现依赖于 JVM 提供的本地方法（Native Method），例如：
        - native Annotation[] getDeclaredAnnotations0(boolean publicOnly);
        - native \<A extends Annotation> A getAnnotation(Class\<A> annotationClass);
      - JVM 在加载类时会解析 .class 文件中的注解信息，并将其存储在内存中，供反射机制使用。
    - 因此，注解解析的底层实现主要依赖于 Java 的反射机制和字节码文件的存储。通过 Retention 元注解可以控制注解的保留策略，当使用 RetentionPolicy.RUNTIME 时，可以在运行时通过反射 API 来解析注解信息。在 JVM 层面，会从字节码文件中读取注解信息，并创建注解的代理对象来获取注解的属性值。
  - Java注解的作用域
    - 注解的作用域（Scope）指的是注解可以应用在哪些程序元素上，例如类、方法、字段等。Java注解的作用域可以分为三种：
    - 类级别作用域：用于描述类的注解，通常放置在类定义的上面，可以用来指定类的一些属性，如类的访问级别、继承关系、注释等。
    - 方法级别作用域：用于描述方法的注解，通常放置在方法定义的上面，可以用来指定方法的一些属性，如方法的访问级别、返回值类型、异常类型、注释等。
    - 字段级别作用域：用于描述字段的注解，通常放置在字段定义的上面，可以用来指定字段的一些属性，如字段的访问级别、默认值、注释等。

  - Java的异常体系主要基于两大类：Throwable类及其子类。Throwable有两个重要的子类：Error和Exception，它们分别代表了不同类型的异常情况。
    - Error（错误）：表示运行时环境的错误。错误是程序无法处理的严重问题，如系统崩溃、虚拟机错误、动态链接失败等。通常，程序不应该尝试捕获这类错误。例如，OutOfMemoryError、StackOverflowError等。
    - Exception（异常）：表示程序本身可以处理的异常条件。异常分为两大类：
      - 非运行时异常：这类异常在编译时期就必须被捕获或者声明抛出。它们通常是外部错误，如文件不存在（FileNotFoundException）、类未找到（ClassNotFoundException）等。非运行时异常强制程序员处理这些可能出现的问题，增强了程序的健壮性。
      - 运行时异常：这类异常包括运行时异常（RuntimeException）和错误（Error）。运行时异常由程序错误导致，如空指针访问（NullPointerException）、数组越界（ArrayIndexOutOfBoundsException）等。运行时异常是不需要在编译时强制捕获或声明的。
  -  Java异常处理有哪些？
    - 异常处理是通过使用try-catch语句块来捕获和处理异常。以下是Java中常用的异常处理方式：
      - try-catch语句块：用于捕获并处理可能抛出的异常。try块中包含可能抛出异常的代码，catch块用于捕获并处理特定类型的异常。可以有多个catch块来处理不同类型的异常。
      - throw语句：用于手动抛出异常。可以根据需要在代码中使用throw语句主动抛出特定类型的异常。
      - throws关键字：用于在方法声明中声明可能抛出的异常类型。如果一个方法可能抛出异常，但不想在方法内部进行处理，可以使用throws关键字将异常传递给调用者来处理。
      - finally块：用于定义无论是否发生异常都会执行的代码块。通常用于释放资源，确保资源的正确关闭。
  - 抛出异常为什么不用throws？
    - 如果异常是未检查异常或者在方法内部被捕获和处理了，那么就不需要使用throws。
    - Unchecked Exceptions：未检查异常（unchecked exceptions）是继承自RuntimeException类或Error类的异常，编译器不强制要求进行异常处理。因此，对于这些异常，不需要在方法签名中使用throws来声明。示例包括NullPointerException、ArrayIndexOutOfBoundsException等。
    - 捕获和处理异常：另一种常见情况是，在方法内部捕获了可能抛出的异常，并在方法内部处理它们，而不是通过throws子句将它们传递到调用者。这种情况下，方法可以处理异常而无需在方法签名中使用throws。
  - try catch中的语句运行情况
    - try块中的代码将按顺序执行，如果抛出异常，将在catch块中进行匹配和处理，然后程序将继续执行catch块之后的代码。如果没有匹配的catch块，异常将被传递给上一层调用的方法。
  - try{return “a”} finally{return “b”}这条语句返回啥

    - finally块中的return语句会覆盖try块中的return返回，因此，该语句将返回"b"。

  - ‘==’ 与 equals 有什么区别？
    - 对于字符串变量来说，使用"=="和"equals"比较字符串时，其比较方法不同。"=="比较两个变量本身的值，即两个对象在内存中的首地址，"equals"比较字符串包含内容是否相同。
    - 对于非字符串变量来说，如果没有对equals()进行重写的话，"==" 和 "equals"方法的作用是相同的，都是用来比较对象在堆内存中的首地址，即用来比较两个引用变量是否指向同一个对象。
    - ==：对于基本类型（int、char、double 等），== 比较的是值本身。对于引用类型（对象），== 比较的是内存地址（引用是否相同），即是否指向同一个对象。
    - equals()：默认实现（Object 类中的 equals）：比较的是引用地址，效果和 == 一样。子类重写后（比如 String、Integer 等）：比较的是对象的内容。
  -  hashcode和equals方法有什么关系？
    - 在 Java 中，对于重写 equals 方法的类，通常也需要重写 hashCode 方法，并且需要遵循以下规定：
      - 一致性：如果两个对象使用 equals 方法比较结果为 true，那么它们的 hashCode 值必须相同。也就是说，如果 obj1.equals(obj2) 返回 true，那么 obj1.hashCode() 必须等于 obj2.hashCode()。
      - 非一致性：如果两个对象的 hashCode 值相同，它们使用 equals 方法比较的结果不一定为 true。即 obj1.hashCode() == obj2.hashCode() 时，obj1.equals(obj2) 可能为 false，这种情况称为哈希冲突。
    - hashCode 和 equals 方法是紧密相关的，重写 equals 方法时必须重写 hashCode 方法，以保证在使用哈希表等数据结构时，对象的相等性判断和存储查找操作能够正常工作。而重写 hashCode 方法时，需要确保相等的对象具有相同的哈希码，但相同哈希码的对象不一定相等。
  - String、StringBuffer、StringBuilder的区别和联系
    - 可变性 ：String 是不可变的（Immutable），一旦创建，内容无法修改，每次修改都会生成一个新的对象。StringBuilder 和 StringBuffer 是可变的（Mutable），可以直接对字符串内容进行修改而不会创建新对象。
    - 线程安全性 ：String 因为不可变，天然线程安全。StringBuilder 不是线程安全的，适用于单线程环境。StringBuffer 是线程安全的，其方法通过 synchronized 关键字实现同步，适用于多线程环境。
    - 性能 ：String 性能最低，尤其是在频繁修改字符串时会生成大量临时对象，增加内存开销和垃圾回收压力。StringBuilder 性能最高，因为它没有线程安全的开销，适合单线程下的字符串操作。StringBuffer 性能略低于 StringBuilder，因为它的线程安全机制引入了同步开销。
    - 使用场景 ：如果字符串内容固定或不常变化，优先使用 String。如果需要频繁修改字符串且在单线程环境下，使用 StringBuilder。如果需要频繁修改字符串且在多线程环境下，使用 StringBuffer。
  - Java 新特性
    - Java 8 你知道有什么新特性？
      #image("Screenshot_20250922_152507.png")
    - Lambda 表达式了解吗？
      - 



     