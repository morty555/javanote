计算机网络面试题
- 网络模型
  - 网络OSI模型和TCP/IP模型分别介绍一下
    - OSI七层模型
      - 为了使得多种设备能通过网络相互通信，和为了解决各种不同设备在网络互联中的兼容性问题，国际标准化组织制定了开放式系统互联通信参考模型，也就是 OSI 网络模型，该模型主要有 7 层，分别是应用层、表示层、会话层、传输层、网络层、数据链路层以及物理层。
      - 每一层负责的职能都不同，如下：
        - 应用层，负责给应用程序提供统一的接口；
        - 表示层，负责把数据转换成兼容另一个系统能识别的格式；
        - 会话层，负责建立、管理和终止表示层实体之间的通信会话；
        #image("Screenshot_20250902_110531.png")
        - 传输层，负责端到端的数据传输；
        - 网络层，负责数据的路由、转发、分片；
        - 数据链路层，负责数据的封帧和差错检测，以及 MAC 寻址；
        #image("Screenshot_20250902_110805.png")
        #image("Screenshot_20250902_110812.png")
        #image("Screenshot_20250902_110831.png")
        - 物理层，负责在物理网络中传输数据帧；
    - 由于 OSI 模型实在太复杂，提出的也只是概念理论上的分层，并没有提供具体的实现方案。事实上，我们比较常见，也比较实用的是四层模型，即 TCP/IP 网络模型，Linux 系统正是按照这套网络模型来实现网络协议栈的。
    - TCP/IP模型
      - TCP/IP协议被组织成四个概念层，其中有三层对应于ISO参考模型中的相应层。ICP/IP协议族并不包含物理层和数据链路层，因此它不能独立完成整个计算机网络系统的功能，必须与许多其他的协议协同工作。TCP/IP 网络通常是由上到下分成 4 层，分别是应用层，传输层，网络层和网络接口层。
      - 应用层 支持 HTTP、SMTP 等最终用户进程
        - SMTP是简单邮件传输协议，用于电子邮件的发送和传输
      - 传输层 处理主机到主机的通信（TCP、UDP）
      - 网络层 寻址和路由数据包（IP 协议）
      - 链路层 通过网络的物理电线、电缆或无线信道移动比特
- 应用层
  - 应用层协议有哪些
    - HTTP、HTTPS、CDN、DNS、FTP 都是应用层协议
      - ftp是文件传输协议
  - HTTP报文有哪些部分？
    - 分请求报文和响应报文
      - 请求报文
        - 请求行：包含请求方法、请求目标（URL或URI）和HTTP协议版本。
        - 请求头部：包含关于请求的附加信息，如Host、User-Agent、Content-Type等。
        - 空行：请求头部和请求体之间用空行分隔。
        - 请求体：可选，包含请求的数据，通常用于POST请求等需要传输数据的情况。
      - 响应报文
        - 状态行：包含HTTP协议版本、状态码和状态信息。
        - 响应头部：包含关于响应的附加信息，如Content-Type、Content-Length等。
        - 空行：响应头部和响应体之间用空行分隔。
        - 响应体：包含响应的数据，通常是服务器返回的HTML、JSON等内容。
  - HTTP常用的状态码
    - 1xx 类状态码属于提示信息，是协议处理中的一种中间状态，实际用到的比较少。
    - 2xx 类状态码表示服务器成功处理了客户端的请求，也是我们最愿意看到的状态。
    - 3xx 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是重定向。
    - 4xx 类状态码表示客户端发送的报文有误，服务器无法处理，也就是错误码的含义。
    - 5xx 类状态码表示客户端请求报文正确，但是服务器处理时内部发生了错误，属于服务器端的错误码。
    - 其中常见的状态码有
      - 200：请求成功；
      - 301：永久重定向；302：临时重定向；
      - 404：无法找到此页面；405：请求的方法类型不支持；
      - 500：服务器内部出错。
  - HTTP返回状态301 302分别是什么？
    - 3xx 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是重定向。
    - 「301 Moved Permanently」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。
    - 301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。
  - http 502和 504 的区别？
    - 502 Bad Gateway：作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。
    - 504 Gateway Time-out：作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器收到响应。
    - 举一个例子，假设 nginx 是代理服务器，收到客户端的请求后，将请求转发到后端服务器（tomcat 等）。
      - 当nginx收到了无效的响应时，就返回502。
      - 当nginx超过自己配置的超时时间，还没有收到请求时，就返回504错误。
  -  HTTP层请求的类型有哪些？
    - GET：用于请求获取指定资源，通常用于获取数据。
    - POST：用于向服务器提交数据，通常用于提交表单数据或进行资源的创建。
    - PUT：用于向服务器更新指定资源，通常用于更新已存在的资源。
    - DELETE：用于请求服务器删除指定资源。
    - HEAD：类似于GET请求，但只返回资源的头部信息，用于获取资源的元数据而不获取实际内容。
  - GET和POST的使用场景，有哪些区别？
    - GET的语义是从服务器获取指定的资源，这个资源可以是静态的文本、页面、图片视频等。GET 请求的参数位置一般是写在 URL 中，URL规定只能支持ASCII,所以GET请求的参数只允许ASCII字符，而且浏览器会对 URL 的长度有限制（HTTP协议本身对 URL长度并没有做任何规定）。
    - 比如，你打开我的文章，浏览器就会发送 GET 请求给服务器，服务器就会返回文章的所有文字及资源。
    - POST 的语义是根据请求负荷（报文body）对指定的资源做出处理，POST 请求携带数据的位置一般是写在报文 body 中，body 中的数据可以是任意格式的数据，只要客户端与服务端协商好即可，而且浏览器不会对 body 大小做限制。
    - POST 请求携带数据的位置一般是写在报文 body 中，body 中的数据可以是任意格式的数据，只要客户端与服务端协商好即可，而且浏览器不会对 body 大小做限制。
    - 比如，你在我文章底部，敲入了留言后点击「提交」（暗示你们留言），浏览器就会执行一次 POST 请求，把你的留言文字放进了报文 body 里，然后拼接好 POST 请求头，通过 TCP 协议发送给服务器。
    - 如果从 RFC 规范定义的语义来看：
      - GET 方法就是安全且幂等的，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。所以，可以对 GET 请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中 GET 请求可以保存为书签。
      - POST 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以不是幂等的。所以，浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签。 
    - 但是实际过程中，开发者不一定会按照 RFC 规范定义的语义来实现 GET 和 POST 方法。比如：
      - 可以用 GET 方法实现新增或删除数据的请求，这样实现的 GET 方法自然就不是安全和幂等。
      - 可以用 POST 方法实现查询数据的请求，这样实现的 POST 方法自然就是安全和幂等。
  - HTTP的长连接是什么？
    - HTTP 协议采用的是「请求-应答」的模式，也就是客户端发起了请求，服务端才会返回响应，一来一回这样子。
    - 由于 HTTP 是基于 TCP 传输协议实现的，客户端与服务端要进行 HTTP 通信前，需要先建立 TCP 连接，然后客户端发送 HTTP 请求，服务端收到后就返回响应，至此「请求-应答」的模式就完成了，随后就会释放 TCP 连接。
    - 如果每次请求都要经历这样的过程：建立 TCP -> 请求资源 -> 响应资源 -> 释放连接，那么此方式就是 HTTP 短连接，如下图：
    #image("Screenshot_20250902_143627.png")
    - 这样实在太累人了，一次连接只能请求一次资源。
    - 能不能在第一个 HTTP 请求完后，先不断开 TCP 连接，让后续的 HTTP 请求继续使用此连接？
    - 当然可以，HTTP 的 Keep-Alive 就是实现了这个功能，可以使用同一个 TCP 连接来发送和接收多个 HTTP 请求/应答，避免了连接建立和释放的开销，这个方法称为 HTTP 长连接。
    - HTTP 长连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。
  -  HTTP默认的端口是什么？
    - http 是 80，https 默认是 443。
  -  HTTP1.1怎么对请求做拆包，具体来说怎么拆的？
    - 在HTTP/1.1中，请求的拆包是通过"Content-Length"头字段来进行的。该字段指示了请求正文的长度，服务器可以根据该长度来正确接收和解析请求。
    - 具体来说，当客户端发送一个HTTP请求时，会在请求头中添加"Content-Length"字段，该字段的值表示请求正文的字节数。
    - 服务器在接收到请求后，会根据"Content-Length"字段的值来确定请求的长度，并从请求中读取相应数量的字节，直到读取完整个请求内容。
    - 这种基于"Content-Length"字段的拆包机制可以确保服务器正确接收到完整的请求，避免了请求的丢失或截断问题。
  -  http 断点重传是什么？
    - 断点续传是HTTP/1.1协议支持的特性。实现断点续传的功能，需要客户端记录下当前的下载进度，并在需要续传的时候通知服务端本次需要下载的内容片段。
    - 一个最简单的断点续传流程如下：
      - 客户端开始下载一个1024K的文件，服务端发送Accept-Ranges: bytes来告诉客户端，其支持带Range的请求
      - 假如客户端下载了其中512K时候网络突然断开了，过了一会网络可以了，客户端再下载时候，需要在HTTP头中申明本次需要续传的片段：Range:bytes=512000-这个头通知服务端从文件的512K位置开始传输文件，直到文件内容结束
      - 服务端收到断点续传请求，从文件的512K位置开始传输，并且在HTTP头中增加：Content-Range:bytes 512000-/1024000,Content-Length: 512000。并且此时服务端返回的HTTP状态码应该是206 Partial Content。如果客户端传递过来的Range超过资源的大小,则响应416 Requested Range Not Satisfiable
    - 通过上面流程可以看出：断点续传中4个HTTP头不可少的，分别是Range头、Content-Range头、Accept-Ranges头、Content-Length头。其中第一个Range头是客户端发过来的，后面3个头需要服务端发送给客户端。下面是它们的说明：
      - Accept-Ranges: bytes：这个值声明了可被接受的每一个范围请求, 大多数情况下是字节数 bytes
      - Range: bytes=开始位置-结束位置：Range是浏览器告知服务器所需分部分内容范围的消息头。
  - http为什么不安全
    - HTTP 由于是明文传输，所以安全上存在以下三个风险：
      - 窃听风险，比如通信链路上可以获取通信内容，用户号容易没。
      - 篡改风险，比如强制植入垃圾广告，视觉污染，用户眼容易瞎。
      - 冒充风险，比如冒充淘宝网站，用户钱容易没。
    - HTTPS 在 HTTP 与 TCP 层之间加入了 SSL/TLS 协议，可以很好的解决了上述的风险：
      - 信息加密：交互信息无法被窃取，但你的号会因为「自身忘记」账号而没。
      - 校验机制：无法篡改通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾广告。
      - 身份证书：证明淘宝是真的淘宝网，但你的钱还是会因为「剁手」而没。
    - HTTP和HTTPS 的区别？
      - HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。
      - HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。
      - 两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。
      - HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。
  - HTTPS握手过程说一下
    - 传统的 TLS 握手基本都是使用 RSA 算法来实现密钥交换的，在将 TLS 证书部署服务端时，证书文件其实就是服务端的公钥，会在 TLS 握手阶段传递给客户端，而服务端的私钥则一直留在服务端，一定要确保私钥不能被窃取。
    - 在 RSA 密钥协商算法中，客户端会生成随机密钥，并使用服务端的公钥加密后再传给服务端。根据非对称加密算法，公钥加密的消息仅能通过私钥解密，这样服务端解密后，双方就得到了相同的密钥，再用它加密应用消息。
    - 




