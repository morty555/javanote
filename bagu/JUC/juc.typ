+ JAVA并发面试题
  - 多线程
    -  java里面的线程和操作系统的线程一样吗？
      - Java 底层会调用 pthread_create 来创建线程，所以本质上 java 程序创建的线程，就是和操作系统线程是一样的，是 1 对 1 的线程模型。
    - 使用多线程要注意哪些问题？
      - 要保证多线程的程序是安全，不要出现数据竞争造成的数据混乱的问题。
      - Java的线程安全在三个方面体现：
        - 原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作，在Java中使用了atomic包（这个包提供了一些支持原子操作的类，这些类可以在多线程环境下保证操作的原子性）和synchronized关键字来确保原子性；
        - 可见性：一个线程对主内存的修改可以及时地被其他线程看到，在Java中使用了synchronized和volatile这两个关键字确保可见性；
        - 有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，在Java中使用了happens-before原则来确保有序性。
        - JMM 定义了几个常见的 happens-before 关系：
          + 程序次序规则

            在一个线程内，按照代码顺序，前面的操作 happens-before 后面的操作。

           （即单线程语义：写在前的代码一定先执行）
          + 监视器锁规则

            对一个锁的解锁（unlock）happens-before 后续对这个锁的加锁（lock）。

            保证临界区的内存可见性）
          + volatile 变量规则
            
            对一个 volatile 变量的写 happens-before 后续对这个变量的读。

            （保证变量的可见性，不保证复合操作的原子性）
          + 传递性
            
            如果 A happens-before B，B happens-before C，那么 A happens-before C。
          + 线程启动规则
            
            在主线程中调用 Thread.start() 之前的操作 happens-before 新线程中的任何操作。
          + 线程终止规则
            
            线程中的所有操作 happens-before 其他线程检测到它结束（如通过 Thread.join() 返回）。
          + 线程中断规则
            
            对线程 interrupt() 的调用 happens-before 被中断线程的代码检测到中断事件。
          + 对象终结规则
            
            对象的构造函数执行结束 happens-before 该对象的 finalize() 方法开始。
          - JMM
          #image("Screenshot_20250901_200847.png")
    - 保证数据的一致性有哪些方案呢？
      - 事务管理：使用数据库事务来确保一组数据库操作要么全部成功提交，要么全部失败回滚。通过ACID（原子性、一致性、隔离性、持久性）属性，数据库事务可以保证数据的一致性。
      - 锁机制：使用锁来实现对共享资源的互斥访问。在 Java 中，可以使用 synchronized 关键字、ReentrantLock 或其他锁机制来控制并发访问，从而避免并发操作导致数据不一致。
      - 版本控制：通过乐观锁的方式，在更新数据时记录数据的版本信息，从而避免同时对同一数据进行修改，进而保证数据的一致性。
    - 线程的创建方式有哪些?
      

