= 问题排查
- CPU 100% 问题怎么排查？


- mysql索引失效 explain看计划 怎么分析多个索引的好坏
  - possible_keys：理论上可用的索引。
  - key：优化器实际选择的索引（最关键！）。
  - rows：预估扫描行数（越小越好）。
  - filtered：过滤比例（越高越好）。
  - type：访问类型（越靠前越好，性能等级如下）：
    - system > const > eq_ref > ref > range > index > all
    #image("Screenshot_20251021_144910.png")
  - Extra：额外信息：
    - Using where：使用了where条件过滤。
    - Using index：覆盖索引（不回表，非常好）。
    - Using filesort：需要额外排序，性能较差。
    - Using temporary：使用临时表，性能差。


- 什么方法能感知到数据变化，具体怎么做
  - 定时轮询
  - binlog
  - 订阅
  - 数据库触发器（Trigger）

- 网页非常慢转圈圈的时候，要定位问题需要从哪些角度？
  - 最直接的办法就是抓包，排查的思路大概有：
    - 先确定是服务端的问题，还是客户端的问题。先确认浏览器是否可以访问其他网站，如果不可以，说明客户端网络自身的问题，然后检查客户端网络配置（连接wifi正不正常，有没有插网线）；如果可以正常其他网页，说明客户端网络是可以正常上网的。
    - 如果客户端网络没问题，就抓包确认 DNS 是否解析出了 IP 地址，如果没有解析出来，说明域名写错了，如果解析出了 IP 地址，抓包确认有没有和服务端建立三次握手，如果能成功建立三次握手，并且发出了 HTTP 请求，但是就是没有显示页面，可以查看服务端返回的响应码：
      - 如果是404错误码，检查输入的url是否正确；
      - 如果是500，说明服务器此时有问题；
      - 如果是200，F12看看前端代码有问题导致浏览器没有渲染出页面。
    - 如果客户端网络是正常的，但是访问速度很慢，导致很久才显示出来。这时候要看客户端的网口流量是否太大的了，导致tcp发生丢包之类的问题。

- 用什么工具检测IP的连通性？用端口呢？
  - 检测 IP 连通性
    - PING 
      - 测试主机是否可达（ICMP协议）
      - 最常用。能通说明IP层（第3层）无问题。
    - traceroute（Windows 下是 tracert）
      - 跟踪路由路径
      - 查看经过的路由节点，可定位在哪一跳丢包。
    - mtr
      - 结合 ping + traceroute 的实时监控工具
      - 连通性和路径质量的动态监控。
    - arping
      -	测试同一局域网内主机的 MAC 层连通性
      - 基于ARP协议，比ping更底层（第2层）。
  - 检测端口连通性
    - telnet
    - nc (netcat)
      - 非常灵活（-z扫描端口，-v显示详情）。
    - nmap
      - 可检测端口状态、服务版本、操作系统等。
    - curl
      - 若能返回HTTP响应，说明端口正常且服务可访问。
    - ss / netstat
      - 确认本机服务是否在指定端口监听。


- 产品上线后，有一天发生缓存雪崩了导致sql宕机服务宕机，怎么立马解决？
  - sql宕机原因
    - 瞬时大量请求打到数据库，超过数据库承载能力，导致连接数耗尽或响应变慢，每个线程都卡在 getConnection() 阻塞上，最终宕机。
    - 高并发读触发 N+1 查询、锁竞争、慢 SQL 。所有请求同时去查同一个表；热点行被锁住；造成事务等待、死锁、回滚；
  - 限流 + 熔断
    - 限流：Nginx / Gateway / Sentinel / RateLimiter 等限制请求速率；
      - 只放行 10% 的流量到后端；其他 90% 请求直接返回缓存的静态页面（如“系统繁忙，请稍后再试”）。
    - 熔断：对访问数据库的请求增加降级逻辑（如返回缓存的旧数据或默认数据）；
    - 隔离：优先保护关键服务，比如用户下单接口优先，其它功能限流或停用。
  - 临时兜底缓存
    - 在应用中加入 临时缓存（Fallback Cache），即使数据过期，也暂时继续使用旧值（比如 TTL 过期后延迟删除）。
    - 如果有 Redis Cluster，可快速人工插入热点 Key 的缓存数据，避免再查询数据库。
  - 数据库层面限流与保护
    - 降低数据库连接数上限；
    - 暂时关闭非核心业务访问数据库；
    - 开启只读副本服务，分担读请求；
    - 调整 MySQL 的 max_connections、slow_query_log 等，观察恢复情况。
  - 逐步恢复缓存
    - 分批、随机延迟重建缓存；
    - 不要一次性让应用重新加载全部数据；
    - 可以写一个定时任务或脚本，逐步刷新热点 Key。
  - 事后复盘：彻底防止再次发生
    - 缓存雪崩的根因
      - 大量 key 同时过期；
      - Redis 节点宕机或重启；
      - 代码中主动清空缓存；
      - 热点数据没有兜底机制。
    - 预防措施
      - 设置 过期时间随机化
      - 使用 互斥锁 / 双重检测机制
      - 使用 多级缓存
      - 热点数据预热机制
      - 异步更新 + 延迟双删策略


- 出现了慢查询怎么定位？
  - 开启 MySQL 慢查询日志
    - 在 MySQL 中配置 slow_query_log。
    ```
    SHOW VARIABLES LIKE '%slow_query%'; 
    ```
    - 如果未开启：
    ```
    SET GLOBAL slow_query_log = ON;
    SET GLOBAL slow_query_log_file = '/var/lib/mysql/slow.log';
    SET GLOBAL long_query_time = 1;  -- 超过 1 秒的查询记录为慢查询
    SET GLOBAL log_queries_not_using_indexes = ON;  -- 没用索引的查询也记录

    ```
    - 然后查看日志文件：
      ```
      cat /var/lib/mysql/slow.log
      ```
    - 或使用官方工具
      ```
      mysqldumpslow /var/lib/mysql/slow.log

      ```
    - 或更强大的分析工具：
    ```
    pt-query-digest /var/lib/mysql/slow.log
    ```
  - 方式 2：通过 Performance Schema 定位
    - 新版本 MySQL（5.7+）可以直接通过性能模式表查：
    ```
        SELECT *
    FROM performance_schema.events_statements_summary_by_digest
    ORDER BY AVG_TIMER_WAIT DESC
    LIMIT 10;

    ```
  - 应用层监控
    - 在日志里开启 SQL 打印；
    - 接入 APM 工具
    - 配合日志链路可以看到具体 SQL 的耗时。
  - 分析执行计划 (EXPLAIN)
  - 如何优化
    - 添加或优化索引
    - 重写 SQL 语句
    - 分表分库
    - 增加缓存
    - 调整数据库配置参数
    - 请求都打到热点数据上，导致锁竞争严重
    - 小表驱动大表
      ```
            SELECT * 
      FROM customers c
      JOIN orders o ON o.customer_id = c.id;
      ```
      - 外层扫描 1 万次（customers）
      - 每次查 orders → 共 1 万次索引查找
    - 避免使用 SELECT \*
    - in换成小于等于 
      - MySQL 会把 IN (3,5,9,12) 转换成多个 OR 条件：
      - 优化器会对每个值单独查一次索引，然后合并结果集。
      - 当 IN 的元素较多时（例如几十个或上百个），这就意味着要做多次索引查找 → 随机 I/O 开销大。
      - 如果 IN 的值分布很散，也会导致索引跳跃扫描（random seek）→ 缓存命中率差。


- 实际中如何排查解决慢接口问题
  - 监控/日志初步判断
    - 通过 APM 工具（如 SkyWalking、Pinpoint）查看接口调用链，定位慢接口。
    - 查看应用日志，确认是否有异常或错误信息。
  - 确定慢在哪一层
    - 网络层
      - 使用 ping、traceroute 等工具检查网络延迟和丢包。
      - 检查防火墙、负载均衡器等网络设备配置。
    - Controller 层
      - 是否有过大的入参/出参 JSON 序列化（尤其是 List 大对象）。
      - 是否有不必要的校验/拦截器处理
      - 是否有文件上传下载耗时。
    - Service 层
      - 重复查询数据库；
      - 逻辑循环调用外部接口；
      - Stream/for循环中过多对象创建；
      - 异常被吞导致重试。
    - 数据层
    - 对外依赖（Redis / RPC / 消息队列）

- jvm优化，小对象多的场景如何调整内存
  - 调大新生代 (Young Generation) 占比
    - 如果是短命小对象多，适当调大新生代，让对象尽量在新生代内回收，避免过早晋升到老年代。
  - 增大 Eden 区比例，减少 Survivor 复制成本
    - 若对象很多但生命周期极短（如 Web 请求内创建的临时对象），可适当 提高 Eden 占比（如 8→10），让更多对象直接在 Eden 分配并快速回收。
  - 调整对象晋升（Promotion）策略
    - 适当调高对象晋升年龄（如从 15 调到 20 或更高），让更多短命对象在新生代内被回收，减少晋升到老年代的对象数量。
  - 合理选择 GC 收集器
    - 对于小对象多且生命周期短的应用，G1 GC 或 ZGC 通常表现更好，因为它们对新生代回收更高效，且停顿时间更短。
  - 代码层优化
    - 避免装箱/拆箱
    - 减少不必要的对象创建（如使用对象池、复用对象）
   