= 问题排查
- CPU 100% 问题怎么排查？


- mysql索引失效 explain看计划 怎么分析多个索引的好坏
  - possible_keys：理论上可用的索引。
  - key：优化器实际选择的索引（最关键！）。
  - rows：预估扫描行数（越小越好）。
  - filtered：过滤比例（越高越好）。
  - type：访问类型（越靠前越好，性能等级如下）：
    - system > const > eq_ref > ref > range > index > all
    #image("Screenshot_20251021_144910.png")
  - Extra：额外信息：
    - Using where：使用了where条件过滤。
    - Using index：覆盖索引（不回表，非常好）。
    - Using filesort：需要额外排序，性能较差。
    - Using temporary：使用临时表，性能差。


- 什么方法能感知到数据变化，具体怎么做
  - 定时轮询
  - binlog
  - 订阅
  - 数据库触发器（Trigger）

- 网页非常慢转圈圈的时候，要定位问题需要从哪些角度？
  - 最直接的办法就是抓包，排查的思路大概有：
    - 先确定是服务端的问题，还是客户端的问题。先确认浏览器是否可以访问其他网站，如果不可以，说明客户端网络自身的问题，然后检查客户端网络配置（连接wifi正不正常，有没有插网线）；如果可以正常其他网页，说明客户端网络是可以正常上网的。
    - 如果客户端网络没问题，就抓包确认 DNS 是否解析出了 IP 地址，如果没有解析出来，说明域名写错了，如果解析出了 IP 地址，抓包确认有没有和服务端建立三次握手，如果能成功建立三次握手，并且发出了 HTTP 请求，但是就是没有显示页面，可以查看服务端返回的响应码：
      - 如果是404错误码，检查输入的url是否正确；
      - 如果是500，说明服务器此时有问题；
      - 如果是200，F12看看前端代码有问题导致浏览器没有渲染出页面。
    - 如果客户端网络是正常的，但是访问速度很慢，导致很久才显示出来。这时候要看客户端的网口流量是否太大的了，导致tcp发生丢包之类的问题。

- 用什么工具检测IP的连通性？用端口呢？
  - 检测 IP 连通性
    - PING 
      - 测试主机是否可达（ICMP协议）
      - 最常用。能通说明IP层（第3层）无问题。
    - traceroute（Windows 下是 tracert）
      - 跟踪路由路径
      - 查看经过的路由节点，可定位在哪一跳丢包。
    - mtr
      - 结合 ping + traceroute 的实时监控工具
      - 连通性和路径质量的动态监控。
    - arping
      -	测试同一局域网内主机的 MAC 层连通性
      - 基于ARP协议，比ping更底层（第2层）。
  - 检测端口连通性
    - telnet
    - nc (netcat)
      - 非常灵活（-z扫描端口，-v显示详情）。
    - nmap
      - 可检测端口状态、服务版本、操作系统等。
    - curl
      - 若能返回HTTP响应，说明端口正常且服务可访问。
    - ss / netstat
      - 确认本机服务是否在指定端口监听。


- 产品上线后，有一天发生缓存雪崩了导致sql宕机服务宕机，怎么立马解决？
  - sql宕机原因
    - 瞬时大量请求打到数据库，超过数据库承载能力，导致连接数耗尽或响应变慢，每个线程都卡在 getConnection() 阻塞上，最终宕机。
    - 高并发读触发 N+1 查询、锁竞争、慢 SQL 。所有请求同时去查同一个表；热点行被锁住；造成事务等待、死锁、回滚；
  - 限流 + 熔断
    - 限流：Nginx / Gateway / Sentinel / RateLimiter 等限制请求速率；
      - 只放行 10% 的流量到后端；其他 90% 请求直接返回缓存的静态页面（如“系统繁忙，请稍后再试”）。
    - 熔断：对访问数据库的请求增加降级逻辑（如返回缓存的旧数据或默认数据）；
    - 隔离：优先保护关键服务，比如用户下单接口优先，其它功能限流或停用。
  - 临时兜底缓存
    - 在应用中加入 临时缓存（Fallback Cache），即使数据过期，也暂时继续使用旧值（比如 TTL 过期后延迟删除）。
    - 如果有 Redis Cluster，可快速人工插入热点 Key 的缓存数据，避免再查询数据库。
  - 数据库层面限流与保护
    - 降低数据库连接数上限；
    - 暂时关闭非核心业务访问数据库；
    - 开启只读副本服务，分担读请求；
    - 调整 MySQL 的 max_connections、slow_query_log 等，观察恢复情况。
  - 逐步恢复缓存
    - 分批、随机延迟重建缓存；
    - 不要一次性让应用重新加载全部数据；
    - 可以写一个定时任务或脚本，逐步刷新热点 Key。
  - 事后复盘：彻底防止再次发生
    - 缓存雪崩的根因
      - 大量 key 同时过期；
      - Redis 节点宕机或重启；
      - 代码中主动清空缓存；
      - 热点数据没有兜底机制。
    - 预防措施
      - 设置 过期时间随机化
      - 使用 互斥锁 / 双重检测机制
      - 使用 多级缓存
      - 热点数据预热机制
      - 异步更新 + 延迟双删策略


- 出现了慢查询怎么定位？
  - 开启 MySQL 慢查询日志
    - 在 MySQL 中配置 slow_query_log。
    ```
    SHOW VARIABLES LIKE '%slow_query%'; 
    ```
    - 如果未开启：
    ```
    SET GLOBAL slow_query_log = ON;
    SET GLOBAL slow_query_log_file = '/var/lib/mysql/slow.log';
    SET GLOBAL long_query_time = 1;  -- 超过 1 秒的查询记录为慢查询
    SET GLOBAL log_queries_not_using_indexes = ON;  -- 没用索引的查询也记录

    ```
    - 然后查看日志文件：
      ```
      cat /var/lib/mysql/slow.log
      ```
    - 或使用官方工具
      ```
      mysqldumpslow /var/lib/mysql/slow.log

      ```
    - 或更强大的分析工具：
    ```
    pt-query-digest /var/lib/mysql/slow.log
    ```
  - 方式 2：通过 Performance Schema 定位
    - 新版本 MySQL（5.7+）可以直接通过性能模式表查：
    ```
        SELECT *
    FROM performance_schema.events_statements_summary_by_digest
    ORDER BY AVG_TIMER_WAIT DESC
    LIMIT 10;

    ```
  - 应用层监控
    - 在日志里开启 SQL 打印；
    - 接入 APM 工具
    - 配合日志链路可以看到具体 SQL 的耗时。
  - 分析执行计划 (EXPLAIN)
  - 如何优化
    - 添加或优化索引
    - 重写 SQL 语句
    - 分表分库
    - 增加缓存
    - 调整数据库配置参数
    - 请求都打到热点数据上，导致锁竞争严重
    - 小表驱动大表
      ```
            SELECT * 
      FROM customers c
      JOIN orders o ON o.customer_id = c.id;
      ```
      - 外层扫描 1 万次（customers）
      - 每次查 orders → 共 1 万次索引查找
    - 避免使用 SELECT \*
    - in换成小于等于 
      - MySQL 会把 IN (3,5,9,12) 转换成多个 OR 条件：
      - 优化器会对每个值单独查一次索引，然后合并结果集。
      - 当 IN 的元素较多时（例如几十个或上百个），这就意味着要做多次索引查找 → 随机 I/O 开销大。
      - 如果 IN 的值分布很散，也会导致索引跳跃扫描（random seek）→ 缓存命中率差。


- 实际中如何排查解决慢接口问题
  - 监控/日志初步判断
    - 通过 APM 工具（如 SkyWalking、Pinpoint）查看接口调用链，定位慢接口。
    - 查看应用日志，确认是否有异常或错误信息。
  - 确定慢在哪一层
    - 网络层
      - 使用 ping、traceroute 等工具检查网络延迟和丢包。
      - 检查防火墙、负载均衡器等网络设备配置。
    - Controller 层
      - 是否有过大的入参/出参 JSON 序列化（尤其是 List 大对象）。
      - 是否有不必要的校验/拦截器处理
      - 是否有文件上传下载耗时。
    - Service 层
      - 重复查询数据库；
      - 逻辑循环调用外部接口；
      - Stream/for循环中过多对象创建；
      - 异常被吞导致重试。
    - 数据层
    - 对外依赖（Redis / RPC / 消息队列）

- jvm优化，小对象多的场景如何调整内存
  - 调大新生代 (Young Generation) 占比
    - 如果是短命小对象多，适当调大新生代，让对象尽量在新生代内回收，避免过早晋升到老年代。
  - 增大 Eden 区比例，减少 Survivor 复制成本
    - 若对象很多但生命周期极短（如 Web 请求内创建的临时对象），可适当 提高 Eden 占比（如 8→10），让更多对象直接在 Eden 分配并快速回收。
  - 调整对象晋升（Promotion）策略
    - 适当调高对象晋升年龄（如从 15 调到 20 或更高），让更多短命对象在新生代内被回收，减少晋升到老年代的对象数量。
  - 合理选择 GC 收集器
    - 对于小对象多且生命周期短的应用，G1 GC 或 ZGC 通常表现更好，因为它们对新生代回收更高效，且停顿时间更短。
  - 代码层优化
    - 避免装箱/拆箱
    - 减少不必要的对象创建（如使用对象池、复用对象）
   
- 如果内存溢出了怎么办
  - 先搞清楚是哪种“内存溢出”
    - 堆内存溢出
      - 创建了太多对象；对象未被释放（内存泄漏）
    - 元空间溢出
      - 加载了过多类（如频繁动态加载 Class）
    - 直接内存溢出
      - NIO 申请了太多堆外内存
    - 线程过多
      - 创建线程过多，系统资源不足
    - GC超时
      - GC 一直在回收，效果却很差（内存太紧张）
  - 排查与诊断步骤
    - 查看日志和异常栈
    - 启用 heap dump
  - 解决或预防方案
    - 检查是否有内存泄漏（静态集合、ThreadLocal、未关闭流）
    - 对大对象及时清理（null 或移除引用）
    - 使用流式处理或分页读取，避免一次加载全部数据
    - 缓存要有过期机制或使用弱引用（WeakReference）
    - 避免频繁 new 对象，可以使用对象池（如连接池）
    - JVM 参数调整
    - 业务层面优化
      - 加上队列或限流（比如在 Web 服务中）
      - 拆分任务（批处理）
      - 减少一次性并发量
  - 上线项目出现问题怎么办
    - 保存现场
      - 保存堆转储文件
      - 生成线程快照（防止卡死时）
      - 记录系统信息
    - 判断影响范围
      - 查看是否仅一个实例 OOM，还是整个集群都出问题。
      - 检查是否导致服务不可用（请求超时、502 等）。 
    - 快速处理措施
      - 单节点挂掉
        - 先重启该实例，恢复可用性
      - 多节点同时出问题
        - 临时扩容 / 限流，避免更多请求打爆内存
      - 流量异常暴增
        - 立刻在网关层加限流 / 熔断
      - 定时任务或批处理触发 OOM
        - 	停止任务 / 下线相关功能
    - 如果系统一再 OOM
      - 临时加大 JVM 堆内存（如 -Xmx）
      - 降低线程数 或关闭非核心任务
      - 临时禁用缓存或改为 LRU 缩容策略
      - 分批处理任务，避免一次加载太多数据

- 内存溢出了 有什么手段可以立马生成堆转储快照么
  - 在启动 Java 程序时，可以通过参数让 JVM 在 OOM 时自动生成堆转储：
    - -XX:+HeapDumpOnOutOfMemoryError：当出现 OutOfMemoryError 时自动生成堆转储文件
    - -XX:HeapDumpPath：指定生成的文件路径
  - 如果程序正在运行，可以手动生成：
    - jmap -dump:live,format=b,file=/path/to/heapdump.hprof <pid>
  - 现代 JDK 推荐 jcmd：jcmd <pid> GC.heap_dump /path/to/heapdump.hprof
  - 在代码中动态生成
    - 在代码里捕获 OutOfMemoryError 或任意时机生成：

- 如何排查慢索引
  - 一般从以下几个角度入手：执行计划、SQL 写法、索引设计、统计信息、数据分布等。
  - 确认是否真的“用到了”索引
    - 查看执行计划（EXPLAIN / EXPLAIN ANALYZE）
  - 检查索引是否被正确设计
    - 联合索引最左匹配原则
    - 范围查询导致后续字段失效
    - 索引列参与了函数或隐式转换
  - 确认索引“选择性”是否太低
  - 有时“索引用到了，但仍然慢”，可能是因为排序、分页或回表代价高：
    - 排序未命中索引
    - 分页优化
      - SELECT \* FROM orders ORDER BY id LIMIT 100000, 20;  -- 慢
        - 这样查询会查询前10000跳过，MySQL 仍然需要一行行读出、判断、丢弃，实际扫描了 100020 行，然后丢弃前 100000 行，只保留最后 20 行。
        - 而且100000行是全部数据，并非只有索引
          - MySQL 的执行器和优化器分工决定了它是流式处理
            - 优化器阶段不会预先拿到所有 id
            - 执行器一边读一边计数
            - 当计数到 offset+limit 时才停止  
            - 除非你显式告诉 MySQL 不要取整行，这时就不会回表，速度明显提升。
      - SELECT \* FROM orders WHERE id > ? ORDER BY id LIMIT 20;  -- 利用索引游标
      - 先查 id 再回表
  - 查看慢查询日志
  - 看是否存在回表


- 如果线上频繁full gc，如何排查？
  - 线上频繁 Full GC 是 Java 应用性能问题的一个常见症状，通常意味着 老年代内存不足 或 内存碎片严重。
  - 确认 Full GC 频率
    - 查看 GC 日志或通过监控工具（如 Prometheus + Grafana、SkyWalking、Arthas、JConsole、VisualVM）观察
    - 关注应用指标
      - Heap 使用率：老年代接近 100% 或持续上升
      - Metaspace / PermGen：是否有类加载泄漏
      - GC 停顿时间：Full GC 可能导致 TPS/响应异常
  - 收集关键数据
    - GC 日志
      - 线上开启 GC 日志
      - 分析工具
        - GCViewer
        - GCEasy  
    - Heap Dump
      - 线上堆快照
      - 使用 Eclipse MAT 分析
    - 线程 & 类加载情况
      - 使用 jstack 查看线程堆栈是否有阻塞
      - 查看是否频繁动态生成类（导致 Metaspace 满）
  - 分析 Full GC 触发原因
    - Promotion Failure（年轻代对象晋升失败）Minor GC 后老年代不足
      - 解决：调整堆大小 / 老年代比例 / GC 策略
    - System.gc() 显式调用，GC 日志显示 System.gc()
      - 排查代码，禁用 -XX:+DisableExplicitGC
    - 老年代空间不足
      - 增加老年代、优化对象生命周期
    - 内存泄漏，老年代对象持续增长
      - 找到泄漏对象，优化缓存、集合、静态引用
    - 类加载过多
      - 增加 Metaspace 或排查动态生成类
  - 调优思路
    - 调优 JVM 参数
      - 调整堆和 GC 策略
      - G1GC 对频繁 Full GC 的大对象场景较友好。
    - 代码优化
      - 减少老年代对象分配：
        - 短生命周期对象尽量在年轻代分配
        - 减少大对象数组/集合频繁创建
      - 优化缓存：
        - 限制大小，使用弱引用 / LRU
      - 避免 System.gc() 显式调用
    - 排查内存泄漏
      - 长生命周期对象不断累积 → 堆快照分析
      - 常见泄漏点：
        - 静态集合
        - ThreadLocal
        - 缓存 / Listener / 订阅者未释放